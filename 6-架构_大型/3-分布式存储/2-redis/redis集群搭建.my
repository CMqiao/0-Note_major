<h2><a href="http://www.cnblogs.com/wuxl360/p/5920330.html" id="cb_post_title_url">Redis集群搭建与简单使用</a></h2>

<p>介绍安装环境与版本</p>

<p>用两台虚拟机模拟6个节点，一台机器3个节点，创建出3 master、3 salve 环境。</p>

<p>redis 采用 redis-3.2.4 版本。</p>

<p>两台虚拟机都是 CentOS ，一台 CentOS6.5 （IP:192.168.31.245），一台 CentOS7（IP:192.168.31.210） 。</p>

<p>安装过程</p>

<p>1. 下载并解压</p>

<pre>

&nbsp;</pre>

<p><code>cd</code>&nbsp;<code>/root/software</code></p>

<p><code>wget http:</code><code>//download</code><code>.redis.io</code><code>/releases/redis-3</code><code>.2.4.</code><code>tar</code><code>.gz</code></p>

<p><code>tar</code>&nbsp;<code>-zxvf redis-3.2.4.</code><code>tar</code><code>.gz　</code></p>

<p>2. 编译安装</p>

<pre>
cd redis-3.2.4
make &amp;&amp; make install</pre>

<p>3.&nbsp;将 redis-trib.rb 复制到 /usr/local/bin 目录下</p>

<pre>
cd src
cp redis-trib.rb /usr/local/bin/　　</pre>

<p>4. 创建 Redis 节点</p>

<p>首先在&nbsp;192.168.31.245 机器上 /root/software/redis-3.2.4 目录下创建&nbsp;redis_cluster 目录；</p>

<pre>
mkdir redis_cluster　　</pre>

<p>在&nbsp;redis_cluster 目录下，创建名为7000、7001、7002的目录，并将 redis.conf 拷贝到这三个目录中</p>

<pre>
mkdir 7000 7001 7002&lt;br&gt;cp redis.conf redis_cluster/7000
cp redis.conf redis_cluster/7001
cp redis.conf redis_cluster/7002　　</pre>

<p>分别修改这三个配置文件，修改如下内容</p>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<pre>
port  7000                                        //端口7000,7002,7003        
bind 本机ip                                       //默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群
daemonize    yes                               //redis后台运行
pidfile  /var/run/redis_7000.pid          //pidfile文件对应7000,7001,7002
cluster-enabled  yes                           //开启集群  把注释#去掉
cluster-config-file  nodes_7000.conf   //集群的配置  配置文件首次启动自动生成 7000,7001,7002
cluster-node-timeout  15000                //请求超时  默认15秒，可自行设置
appendonly  yes                           //aof日志开启  有需要就开启，它会每次写操作都记录一条日志　</pre>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<ul>
	<li>接着在另外一台机器上（192.168.31.210），的操作重复以上三步，只是把目录改为7003、7004、7005，对应的配置文件也按照这个规则修改即可</li>
</ul>

<p>5. 启动各个节点</p>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<pre>
第一台机器上执行
redis-server redis_cluster/7000/redis.conf
redis-server redis_cluster/7001/redis.conf
redis-server redis_cluster/7002/redis.conf
 
另外一台机器上执行
redis-server redis_cluster/7003/redis.conf
redis-server redis_cluster/7004/redis.conf
redis-server redis_cluster/7005/redis.conf </pre>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<p>6. 检查 redis 启动情况</p>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<pre>
##一台机器&lt;br&gt;ps -ef | grep redis
root      61020      1  0 02:14 ?        00:00:01 redis-server 127.0.0.1:7000 [cluster]    
root      61024      1  0 02:14 ?        00:00:01 redis-server 127.0.0.1:7001 [cluster]    
root      61029      1  0 02:14 ?        00:00:01 redis-server 127.0.0.1:7002 [cluster]    
 
netstat -tnlp | grep redis
tcp        0      0 127.0.0.1:17000             0.0.0.0:*                   LISTEN      61020/redis-server 
tcp        0      0 127.0.0.1:17001             0.0.0.0:*                   LISTEN      61024/redis-server 
tcp        0      0 127.0.0.1:17002             0.0.0.0:*                   LISTEN      61029/redis-server 
tcp        0      0 127.0.0.1:7000              0.0.0.0:*                   LISTEN      61020/redis-server 
tcp        0      0 127.0.0.1:7001              0.0.0.0:*                   LISTEN      61024/redis-server 
tcp        0      0 127.0.0.1:7002              0.0.0.0:*                   LISTEN      61029/redis-server
1
2
3
4
5
6
7
8
9
10
11
12
13
    
##另外一台机器
ps -ef | grep redis
root       9957      1  0 02:32 ?        00:00:01 redis-server 127.0.0.1:7003 [cluster]
root       9964      1  0 02:32 ?        00:00:01 redis-server 127.0.0.1:7004 [cluster]
root       9971      1  0 02:32 ?        00:00:01 redis-server 127.0.0.1:7005 [cluster]
root      10065   4744  0 02:38 pts/0    00:00:00 grep --color=auto redis
netstat -tlnp | grep redis
tcp        0      0 127.0.0.1:17003         0.0.0.0:*               LISTEN      9957/redis-server 1
tcp        0      0 127.0.0.1:17004         0.0.0.0:*               LISTEN      9964/redis-server 1
tcp        0      0 127.0.0.1:17005         0.0.0.0:*               LISTEN      9971/redis-server 1
tcp        0      0 127.0.0.1:7003          0.0.0.0:*               LISTEN      9957/redis-server 1
tcp        0      0 127.0.0.1:7004          0.0.0.0:*               LISTEN      9964/redis-server 1
tcp        0      0 127.0.0.1:7005          0.0.0.0:*               LISTEN      9971/redis-server 1 </pre>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<p>7.创建集群</p>

<p>Redis 官方提供了 redis-trib.rb 这个工具，就在解压目录的 src 目录中，第三步中已将它复制到 /usr/local/bin 目录中，可以直接在命令行中使用了。使用下面这个命令即可完成安装。</p>

<pre>
redis-trib.rb  create  --replicas  1  192.168.31.245:7000 192.168.31.245:7001  192.168.31.245:7002 192.168.31.210:7003  192.168.31.210:7004  192.168.31.210:7005</pre>

<p>其中，前三个 ip:port 为第一台机器的节点，剩下三个为第二台机器。</p>

<p>等等，出错了。这个工具是用 ruby 实现的，所以需要安装 ruby。安装命令如下：</p>

<p><code>yum -y&nbsp;</code><code>install</code>&nbsp;<code>ruby ruby-devel rubygems rpm-build</code></p>

<p><code>gem&nbsp;</code><code>install</code>&nbsp;<code>redis</code></p>

<p>之后再运行 redis-trib.rb 命令，会出现如下提示：</p>

<p><img alt="" src="http://images2015.cnblogs.com/blog/273364/201609/273364-20160929150634344-1055901726.jpg" /></p>

<p>输入 yes 即可，然后出现如下内容，说明安装成功。</p>

<p><img alt="" src="http://images2015.cnblogs.com/blog/273364/201609/273364-20160929150720000-1999293873.jpg" />　　</p>

<p>8. 集群验证</p>

<p>在第一台机器上连接集群的7002端口的节点，在另外一台连接7005节点，连接方式为&nbsp;redis-cli -h192.168.31.245 -c -p&nbsp;7002&nbsp; ,加参数 -C 可连接到集群，因为上面 redis.conf 将 bind 改为了ip地址，所以 -h 参数不可以省略。</p>

<p>在7005节点执行命令 &nbsp;set hello world&nbsp;，执行结果如下：</p>

<p><img alt="" src="http://images2015.cnblogs.com/blog/273364/201609/273364-20160929152337688-1332730145.jpg" />&nbsp;</p>

<p>然后在另外一台7002端口，查看 key 为 hello 的内容，&nbsp;get hello&nbsp; ，执行结果如下：</p>

<p><img alt="" src="http://images2015.cnblogs.com/blog/273364/201609/273364-20160929152449688-978685655.jpg" /></p>

<p>说明集群运作正常。</p>

<p>简单说一下原理</p>

<p>redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</p>

<p>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做<code>哈希槽 (hash slot)</code>的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用<code>CRC16</code>算法来取模得到所属的<code>slot</code>，然后将这个key 分到哈希槽区间的节点上，具体算法就是：<code>CRC16(key) % 16384。所以我们在测试的时候看到set 和 get 的时候，直接跳转到了7000端口的节点。</code></p>

<p>Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。</p>

<p>需要注意的是：必须要<code>3个或以上</code>的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</p>

<p>&nbsp;</p>

<h1><a href="http://www.cnblogs.com/yuanermen/p/5717885.html" id="cb_post_title_url">Redis 3.2.1集群搭建</a></h1>

<p><strong>一、概述</strong></p>

<p>&nbsp; &nbsp;&nbsp;Redis3.0版本之后支持Cluster.</p>

<p>1.1、redis cluster的现状</p>

<p>&nbsp;　　目前redis支持的cluster特性：</p>

<p>　　1):节点自动发现</p>

<p>　　2):slave-&gt;master 选举,集群容错</p>

<p>　　3):Hot resharding:在线分片</p>

<p>　　4):进群管理:cluster xxx</p>

<p>　　5):基于配置(nodes-port.conf)的集群管理</p>

<p>　　6):ASK 转向/MOVED 转向机制.</p>

<p>1.2、redis cluster 架构</p>

<p>　　1)redis-cluster架构图</p>

<p><img alt="" src="http://images2015.cnblogs.com/blog/17405/201607/17405-20160729120110388-883077606.jpg" /></p>

<p>　　架构细节:</p>

<p>　　(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p>

<p>　　(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.</p>

<p>　　(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</p>

<p>　　(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</p>

<p>&nbsp;</p>

<p>&nbsp; &nbsp;2) redis-cluster选举:容错</p>

<p><img alt="" src="http://images2015.cnblogs.com/blog/17405/201607/17405-20160729120154169-1347608301.jpg" /></p>

<p>　　(1)领着选举过程是集群中所有master参与,如果半数以上master节点与master节点通信超过(cluster-node-timeout),认为当前master节点挂掉.</p>

<p>　　(2):什么时候整个集群不可用(cluster_state:fail),当集群不可用时,所有对集群的操作做都不可用，收到((error) CLUSTERDOWN The cluster is down)错误</p>

<p>&nbsp; &nbsp; 　　a:如果集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成进群的slot映射[0-16383]不完成时进入fail状态.</p>

<p>&nbsp; &nbsp; 　　b:如果进群超过半数以上master挂掉，无论是否有slave集群进入fail状态.</p>

<p>&nbsp;</p>

<p><strong>二、redis cluster安装</strong></p>

<p><strong>&nbsp; &nbsp;&nbsp;</strong>1、下载和解包</p>

<table border="0" cellpadding="0" cellspacing="0">
	<tbody>
		<tr>
			<td>
			<p>1</p>

			<p>2</p>

			<p>3</p>
			</td>
			<td>
			<p><code>cd /usr/local/</code></p>

			<p><code>wget http:</code><code>//download.redis.io/releases/redis-3.2.1.tar.gz</code></p>

			<p><code>tar -zxvf /redis-</code><code>3.2</code><code>.</code><code>1</code><code>.tar.gz</code></p>
			</td>
		</tr>
	</tbody>
</table>

<p>　2、 编译安装</p>

<pre>
 cd redis-3.2.1
 make &amp;&amp; make install

</pre>

<p>&nbsp; 3、创建redis节点</p>

<p>&nbsp; &nbsp; &nbsp;测试我们选择2台服务器，分别为：192.168.1.237，192.168.1.238.每分服务器有3个节点。</p>

<p>&nbsp; 我先在192.168.1.237创建3个节点：</p>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<pre>
  cd /usr/local/
  mkdir redis_cluster  //创建集群目录
  mkdir 7000 7001 7002  //分别代表三个节点    其对应端口 7000 7001 7002
 //创建7000节点为例，拷贝到7000目录
 cp /usr/local/redis-3.2.1/redis.conf  ./redis_cluster/7000/   
 //拷贝到7001目录
 cp /usr/local/redis-3.2.1/redis.conf  ./redis_cluster/7001/   
 //拷贝到7002目录
 cp /usr/local/redis-3.2.1/redis.conf  ./redis_cluster/7002/   </pre>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<p>&nbsp; &nbsp;分别对7001，7002、7003文件夹中的3个文件修改对应的配置</p>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<pre>
daemonize    yes                          //redis后台运行
pidfile  /var/run/redis_7000.pid          //pidfile文件对应7000,7002,7003
port  7000                                //端口7000,7002,7003
cluster-enabled  yes                      //开启集群  把注释#去掉
cluster-config-file  nodes_7000.conf      //集群的配置  配置文件首次启动自动生成 7000,7001,7002
cluster-node-timeout  5000                //请求超时  设置5秒够了
appendonly  yes                           //aof日志开启  有需要就开启，它会每次写操作都记录一条日志</pre>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<p>&nbsp; &nbsp;在192.168.1.238创建3个节点：对应的端口改为7003,7004,7005.配置对应的改一下就可以了。</p>

<p>&nbsp; &nbsp;4、两台机启动各节点(两台服务器方式一样)</p>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<pre>
cd /usr/local
redis-server  redis_cluster/7000/redis.conf
redis-server  redis_cluster/7001/redis.conf
redis-server  redis_cluster/7002/redis.conf
redis-server  redis_cluster/7003/redis.conf
redis-server  redis_cluster/7004/redis.conf
redis-server  redis_cluster/7005/redis.conf</pre>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<p>&nbsp; &nbsp;5、查看服务</p>

<p>&nbsp; &nbsp; &nbsp;&nbsp;ps -ef | grep redis &nbsp; #查看是否启动成功</p>

<p>&nbsp; &nbsp; &nbsp;netstat -tnlp | grep redis #可以看到redis监听端口</p>

<p><strong>三、创建集群</strong></p>

<p>&nbsp;&nbsp;前面已经准备好了搭建集群的redis节点，接下来我们要把这些节点都串连起来搭建集群。官方提供了一个工具：redis-trib.rb(/usr/local/redis-3.2.1/src/redis-trib.rb) 看后缀就知道这鸟东西不能直接执行，它是用ruby写的一个程序，所以我们还得安装ruby.</p>

<pre>
yum -y install ruby ruby-devel rubygems rpm-build </pre>

<p>&nbsp;&nbsp;再用 gem 这个命令来安装 redis接口&nbsp; &nbsp; gem是ruby的一个工具包.</p>

<pre>
gem install redis    //等一会儿就好了
当然，方便操作，两台Server都要安装。</pre>

<p>&nbsp; 上面的步骤完事了，接下来运行一下redis-trib.rb</p>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<pre>
 /usr/local/redis-3.2.1/src/redis-trib.rb</pre>

<p>&nbsp; &nbsp;Usage: redis-trib &lt;command&gt; &lt;options&gt; &lt;arguments ...&gt;</p>

<p>&nbsp; &nbsp;reshard&nbsp; &nbsp; &nbsp; &nbsp; host:port<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --to &lt;arg&gt;<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --yes<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --slots &lt;arg&gt;<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --from &lt;arg&gt;<br />
&nbsp; check&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; host:port<br />
&nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; host:port command arg arg .. arg<br />
&nbsp; set-timeout&nbsp; &nbsp; host:port milliseconds<br />
&nbsp; add-node&nbsp; &nbsp; &nbsp; &nbsp; new_host:new_port existing_host:existing_port<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --master-id &lt;arg&gt;<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --slave<br />
&nbsp; del-node&nbsp; &nbsp; &nbsp; &nbsp; host:port node_id<br />
&nbsp; fix&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; host:port<br />
&nbsp; import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; host:port<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --from &lt;arg&gt;<br />
&nbsp; help&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (show this help)<br />
&nbsp; create&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; host1:port1 ... hostN:portN<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --replicas &lt;arg&gt;</p>

<p>For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster.</p>

<p><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif" /></a></p>

<p>&nbsp; &nbsp; &nbsp;看到这，应该明白了吧， 就是靠上面这些操作 完成redis集群搭建的.</p>

<p>&nbsp;确认所有的节点都启动，接下来使用参数create 创建 (在192.168.1.237中来创建)</p>

<pre>
 /usr/local/redis-3.2.1/src/redis-trib.rb  create  --replicas  1  192.168.1.237:7000 192.168.1.237:7001  192.168.1.237:7003 192.168.1.238:7003  192.168.1.238:7004  192.168.1.238:7005</pre>

<p>&nbsp; &nbsp; 解释下， --replicas&nbsp; 1&nbsp; 表示 自动为每一个master节点分配一个slave节点&nbsp; &nbsp; 上面有6个节点，程序会按照一定规则生成 3个master（主）3个slave(从)</p>

<p>&nbsp; &nbsp; 前面已经提醒过的 防火墙一定要开放监听的端口，否则会创建失败。</p>

<p>&nbsp;运行中，提示Can I set the above configuration? (type &#39;yes&#39; to accept): yes&nbsp; &nbsp; //输入yes</p>

<p>&nbsp;接下来 提示&nbsp; Waiting for the cluster to join..........&nbsp; 安装的时候在这里就一直等等等，没反应，傻傻等半天，看这句提示上面一句，Sending Cluster Meet Message to join the Cluster.</p>

<p>&nbsp; &nbsp; 这下明白了，我刚开始在一台Server上去配，也是不需要等的，这里还需要跑到Server2上做一些这样的操作。</p>

<p>&nbsp; &nbsp; 在192.168.1.238, redis-cli -c -p 700*&nbsp; 分别进入redis各节点的客户端命令窗口， 依次输入 cluster meet 192.168.1.238 7000&hellip;&hellip;</p>

<p>&nbsp; &nbsp; 回到Server1，已经创建完毕了。</p>

<p>&nbsp; &nbsp; 查看一下 /usr/local/redis/src/redis-trib.rb check 192.168.1.237:7000</p>

<p>&nbsp; &nbsp; 到这里集群已经初步搭建好了。</p>

<p>&nbsp;</p>

<p><strong>四、测试</strong></p>

<p>1）get 和 set数据</p>

<p>&nbsp; &nbsp; redis-cli -c -p 7000</p>

<p>&nbsp; &nbsp; 进入命令窗口，直接 set&nbsp; hello&nbsp; howareyou</p>

<p>&nbsp; &nbsp; 直接根据hash匹配切换到相应的slot的节点上。</p>

<p>&nbsp; &nbsp; 还是要说明一下，redis集群有16383个slot组成，通过分片分布到多个节点上，读写都发生在master节点。</p>

<p>&nbsp; 2）假设测试</p>

<p>&nbsp; &nbsp; 果断先把192.168.1.238服务Down掉，（192.168.1.238有1个Master, 2个Slave） ,&nbsp; 跑回192.168.1.238, 查看一下 发生了什么事，192.168.1.237的3个节点全部都是Master，其他几个Server2的不见了</p>

<p>&nbsp; &nbsp; 测试一下，依然没有问题，集群依然能继续工作。</p>

<p>&nbsp; &nbsp; 原因：&nbsp; redis集群&nbsp; 通过选举方式进行容错，保证一台Server挂了还能跑，这个选举是全部集群超过半数以上的Master发现其他Master挂了后，会将其他对应的Slave节点升级成Master.</p>

<p>&nbsp; &nbsp; 疑问： 要是挂的是192.168.1.237怎么办？&nbsp; &nbsp; 哥试了，cluster is down!!&nbsp; &nbsp; 没办法，超过半数挂了那救不了了，整个集群就无法工作了。 要是有三台Server，每台两Master，切记对应的主从节点</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不要放在一台Server,别问我为什么自己用脑子想想看，互相交叉配置主从，挂哪台也没事，你要说同时两台crash了，呵呵哒......</p>

<p>&nbsp; 3）关于一致性</p>

<p>&nbsp; &nbsp; 我还没有这么大胆拿redis来做数据库持久化哥网站数据，只是拿来做cache，官网说的很清楚，Redis Cluster is not able to guarantee strong consistency.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>&nbsp;五、安装遇到的问题</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp;</strong>1、</p>

<p>　　CC adlist.o<br />
　　/bin/sh: cc: command not found<br />
　　make[1]: *** [adlist.o] Error 127<br />
　　make[1]: Leaving directory `/usr/local/redis-3.2.1/src<br />
　　make: *** [all] Error 2</p>

<p>&nbsp; &nbsp; &nbsp;解决办法：GCC没有安装或版本不对，安装一下</p>

<pre>
yum  install  gcc</pre>

<p>&nbsp; &nbsp;2、</p>

<p>　　zmalloc.h:50:31:&nbsp;<br />
　　error: jemalloc/jemalloc.h: No such file or directory<br />
　　zmalloc.h:55:2: error:&nbsp;<br />
<br />
　　#error &quot;Newer version of jemalloc required&quot;<br />
　　make[1]: *** [adlist.o] Error&nbsp;<br />
　　1<br />
　　make[1]: Leaving directory `/data0/src/redis-2.6.2/src<br />
　　make: *** [all]&nbsp;<br />
　　Error 2</p>

<p>&nbsp; &nbsp; 解决办法：原因是没有安装jemalloc内存分配器，可以安装jemalloc 或 直接</p>

<p>&nbsp; &nbsp; &nbsp;输入make MALLOC=libc&nbsp; &amp;&amp; make install</p>

<p>记住该记住的,忘记该忘记的,改变能改变的,接受不能改变的!</p>
