<html>

<body>

<p>表单（from）的数据获取与设置。 获取表单数据 return: Object getData（formatter, deep） formatter：Boolean。默认false。设置true，获取的日期格式是&quot;2010-11-12&quot;字符串。 deep：Boolean。默认true，数据为{user:{name:&quot;111&quot;}}；设置false，数据为{&quot;user.name&quot;: &quot;111&quot;}。 设置表单数据 setData（data, all, deep） data：Object。数据对象。 all：Boolean。默认true。设置true后对表单中所有控件设置值，没有数据则清空处理。 deep：Boolean。默认false。同上。 //根据日历时间的选择，计算请假的天数 /**两个触发事件。选择开始时间时，触发方法getStarttime(); *选择结束时间时，触发方法getEndtime(); */ 开始时间： 结束时间： var stime; var etime; var days; function getStarttime(e) { var starttime=nui.get(&quot;starttime&quot;); stime=starttime.value; countdays(); } function getEndtime(e) { var endtime=nui.get(&quot;endtime&quot;); etime=endtime.value; countdays(); } function countdays(){ if(stime!=null&amp;&amp;etime!=null){ days=(etime-stime)/(24*3600*1000); var day=nui.get(&quot;days&quot;); day.setValue(days); } } //下拉框的设计实现 &lt;1&gt; 使用字典： 是否使用导师经费： &lt;2&gt; 直接定义数据： &lt;3&gt; 在页面定义对象做数据源： 婚姻状况： //页面初始加载时候调用。初始化数据。 $(function(){ var marrystates = [{ state: &quot;已婚&quot; },{ state: &quot;未婚&quot; }]; var marry = nui.get(&quot;ismarried&quot;); marry.load(marrystates); }); &lt;4&gt; 使用文件： country.txt： [{country:&quot;阿尔巴尼亚&quot;}, {country:&quot;阿尔及利亚&quot;}, {country:&quot;阿富汗&quot;}, {country:&quot;阿根廷&quot;}, {country:&quot;阿拉伯联合酋长国&quot;}, {country:&quot;阿鲁巴&quot;}, {country:&quot;阿曼&quot;}, {country:&quot;阿塞拜疆&quot;}] &lt;5&gt;除下拉框，还可以自己输入：allowInput=&quot;true&quot; &lt;6&gt;是用逻辑流返回值直接加载下拉框数据。 部门名称: nui.get(&quot;dw&quot;).load(&quot;cn.edu.shnu.common.org.org.querySecondOrgsForDicts.biz.ext&quot;); 页面加载流转相关： $(function(){ getStuInfo(); }); html文件中定义表格：</p>

<div class="nui-datagrid" id="datagrid1">
<div>
<div>序号</div>

<div>计划年份</div>

<div>年度计划名称</div>

<div>年度应参加培训总人数</div>

<div>年度计划培训总人数</div>
</div>
</div>

<p>******************************** /** * 生成&ldquo;年度应参加培训总人数&rdquo;的值 * @param o */ function onNDYCJPXZRSRenderer(o){ if(isEmptyOrZero(o.record.NDJHHZs.xmsfzrs) || isEmptyOrZero(o.record.NDJHHZs.xmsfynhzrs) || isEmptyOrZero(o.record.NDJHHZs.xmsfqtqkrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfzrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfynhzrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfqtqkrs)){ return &quot;0&quot;; } else{return &quot;111&quot;;} } /** * 生成&ldquo;年度计划培训总人数&rdquo;的值 * @param o */ function onNDJHPXZRSRenderer(o){ if(isEmptyOrZero(o.record.NDJHHZs.shjrs) || isEmptyOrZero(o.record.NDJHHZs.fshjrs)){ return &quot;0&quot;; } else{return &quot;111&quot;;} } *********************** 获取数据表格的数据信息。 var pxjh = grid.getRow(rowIndex); var data = {hzndjhid: pxjh.hzndjhid}; return data.valueOf(xmsfzrs); *********************** F12 是浏览器调试的。 *********************** 查询逻辑流最好方便别人调用，所以，criteria(查询条件)中的sql语句的参数不要指定，应该由调用的前端指定。 例如： 培训等级: 培训机构: *********************** 控制台输出信息语句：consol.log(param); *********************** nui 中，form的方法getData(boolen,boolen); 第一个控制时间格式数据的处理，第二个控制录入时，数据的深度。看mini_ui的API。 *********************** 如果前端调用后端，而一直进不了后端。用F12查看前端代码。特别是调用中的参数设置是否正确。 *********************** 文件原先可以运行，后来报错，可能是项目报-&gt;属性-&gt;依赖 没有设置。 *********************** 熟练的使用SVM版本控制器。 ********************** 系统环境配置，default数据库。在逻辑流中数据库参数，直接填写default，不然数据库变了后会出问题。 ********************** 自动生成 ********************** 构建库：构建库分四大类：数据上下文及MDO操作类，数据库操作类，EOS基础构建类，java基础构建类。 EOS帮助文档-&gt;技术参考-&gt;EOS基础构建库参考。 ********************** 注意，在前端页面书写的时候，尽量使用&quot;ALT+/&quot;提示输入。 但是有些是不会提示输出的，例如，gird.getValues ********************** 对象数组，声明一个对象数组之后，使用数组里面的每一个元素都需要先初始化。 例如：MyClass[] myclass=new MyClass[4]; for(int i=0;i&lt;4;i++){ myclass[i]=new MyClass(); myclass[i].**=i; } ********************** &lt;% %&gt; 标识里面的是jsp代码. &lt;%=变量 %&gt; 是 &lt;% out.println(变量) %&gt; 的简写方式 用户:&lt;%=username%&gt; 用户:&lt;% out.println(username) %&gt; function showReason(){ if(this.getValue()==&quot;01&quot;){ nui.get(&quot;refusedreason&quot;).setEnabled(true); }else{ nui.get(&quot;refusedreason&quot;).setEnabled(false); } } //注意这里&ldquo;this&rdquo;的使用。 //Object对象属性的获取，设置，使用set+Property(大写)? 控件对象可以尝试着使用。 //Object对象属性操作可以用&ldquo;.property&rdquo; 方式使用。</p>


常见的分库方式有水平性和垂直性。一般来说，就是按照用户属性（地市或者ID的hash）进行分库，或者按照业务功能块进行分库。 
水平分库方式主要根据用户属性（如地市）拆分物理数据库。一种常见的方式是将全省划分为几个大区。 
垂直分库方式：根据业务维度和数据的访问量等，进行数据的分离，剥离为多个数据库。例如，将一些公用的配置信息存储到一个数据库中进行单独维护。

垂直划分

按照功能划分，把数据分别放到不同的数据库和服务器。

当一个网站开始刚刚创建时，可能只是考虑一天只有几十或者几百个人访问，数据库可能就个db，所有表都放一起，一台普通的服务器可能就够了，而且开发人员也非常高兴，而且信心十足，因为所有的表都在一个库中，这样查询语句就可以随便关联了，多美的一件事情。但是随着访问压力的增加，读写操作不断增加，数据库的压力绝对越来越大，可能接近极限，这时可能人们想到增加从服务器，做什么集群之类的，可是问题又来了，数据量也快速增长。

这时可以考虑对读写操作进行分离，按照业务把不同的数据放到不同的库中。其实在一个大型而且臃肿的数据库中表和表之间的数据很多是没有关系的，或者更加不需要（join）操作，理论上就应该把他们分别放到不同的服务器。例如用户的收藏夹的数据和博客的数据库就可以放到两个独立的服务器。这个就叫垂直划分（其实叫什么不重要）。 
这里写图片描述

当博客或者收藏夹的数据不断增加后，应该怎么办，这样就引出了另外一个做法，叫水平划分。

水平划分

则把一个表的数据划分到不同的数据库，两个数据库的表结构一样。怎么划分，应该根据一定的规则，可以根据数据的产生者来做引导，上面的数据是由人产生的，可以根据人的id来划分数据库。然后再根据一定的规则，先获知数据在哪个数据库。

其实很多大型网站都经历了数据库垂直划分和水平的划分的阶段。其实这个可以根据经验来确定，不一定由某些硬性的规则。

以刚才的博客为例，数据可以根据userid的奇偶来确定数据的划分。把id为基数的放到A库，为偶数的放B库。

这里写图片描述

这样通过userId就可以知道用户的博客的数据在哪个数据库。其实可以根据userId%10来处理。还可以根据著名的Hash算法来处理。

当初看手机之家的架构是发现他们是： 
水平切分：对数据进行水平分割。

a.最好分到同一个数据库。 
b.一种已经证明是切实可行的方案：主表＋辅表。
c.有3种类型：主表不打散、主表打散无辅表、主表打散有辅表。 
d.但对程序员来说，TA看到的只是一张表，不妨称之为虚表(逻辑表)? ，这张虚表实际上可能是由N张实表(物理表)组成的。

在说句题外话，如果是大型数据库，还可以做读写分离等。

数据库读写分离


Mysql主从配置，实现读写分离

大型网站为了软解大量的并发访问，除了在网站实现分布式负载均衡，远远不够。到了数据业务层、数据访问层，如果还是传统的数据结构，或者只是单单靠一台服务器扛，如此多的数据库连接操作，数据库必然会崩溃，数据丢失的话，后果更是 不堪设想。这时候，我们会考虑如何减少数据库的联接，一方面采用优秀的代码框架，进行代码的优化，采用优秀的数据缓存技术如：memcached,如果资金丰厚的话，必然会想到假设服务器群，来分担主数据库的压力。Ok切入今天微博主题，利用MySQL主从配置，实现读写分离，减轻数据库压力。这种方式，在如今很多网站里都有使用，也不是什么新鲜事情，今天总结一下，方便大家学习参考一下。

概述：搭设一台Master服务器（win8.1系统，Ip：192.168.0.104），搭设两台Slave服务器（虚拟机——一台Ubuntu，一台 Windows Server 2003）

原理：主服务器（Master）负责网站NonQuery操作，从服务器负责Query操作，用户可以根据网站功能模特性块固定访问Slave服务器，或者自己写个池或队列，自由为请求分配从服务器连接。主从服务器利用MySQL的二进制日志文件，实现数据同步。二进制日志由主服务器产生，从服务器响应获取同步数据库。

具体实现：

1、在主从服务器上都装上MySQL数据库，windows系统鄙人安装的是mysql_5.5.25.msi版本，Ubuntu安装的是mysql-5.6.22-linux-glibc2.5-i686.tar

windows安装mysql就不谈了，一般地球人都应该会。鄙人稍微说一下Ubuntu的MySQL安装，我建议不要在线下载安装，还是离线安装的好。大家可以参考  http://www.linuxidc.com/Linux/2013-01/78716.htm 这位不知道大哥还是姐妹，写的挺好按照这个就能装上。在安装的时候可能会出现几种现象，大家可以参考解决一下：

（1）如果您不是使用root用户登录，建议 su - root 切换到Root用户安装，那就不用老是 sudo 了。

（2）存放解压的mysql 文件夹，文件夹名字最好改成mysql

（3）在./support-files/mysql.server start 启动MySQL的时候，可能会出现一个警告，中文意思是启动服务运行读文件时，忽略了my.cnf文件，那是因为my.cnf的文件权限有问题，mysql会认为该文件有危险不会执行。但是mysql还会启动成功，但如果下面配置从服务器参数修改my.cnf文件的时候，你会发现文件改过了，但是重启服务时，修改过后的配置没有执行，而且您 list一下mysql的文件夹下会发现很多.my.cnf.swp等中间文件。这都是因为MySQL启动时没有读取my.cnf的原因。这时只要将my.cnf的文件权限改成my_new.cnf的权限一样就Ok，命令：chmod 644 my.cnf就Ok



（4）Ubuntu中修改文档内容没有Vim，最好把Vim 装上，apt-get install vim,不然估计会抓狂。

这时候我相信MySQL应该安装上去了。

2、配置Master主服务器

（1）在Master MySQL上创建一个用户‘repl’，并允许其他Slave服务器可以通过远程访问Master，通过该用户读取二进制日志，实现数据同步。


复制代码
1 mysql>create user repl; //创建新用户
2 //repl用户必须具有REPLICATION SLAVE权限，除此之外没有必要添加不必要的权限，密码为mysql。说明一下192.168.0.%，这个配置是指明repl用户所在服务器，这里%是通配符，表示192.168.0.0-192.168.0.255的Server都可以以repl用户登陆主服务器。当然你也可以指定固定Ip。
3 mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.0.%' IDENTIFIED BY 'mysql';
复制代码
（2）找到MySQL安装文件夹修改my.Ini文件。mysql中有好几种日志方式，这不是今天的重点。我们只要启动二进制日志log-bin就ok。

 在[mysqld]下面增加下面几行代码


1 server-id=1   //给数据库服务的唯一标识，一般为大家设置服务器Ip的末尾号
2 log-bin=master-bin
3 log-bin-index=master-bin.index
（3）查看日志

mysql> SHOW MASTER STATUS;
+-------------------+----------+--------------+------------------+
| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+-------------------+----------+--------------+------------------+
| master-bin.000001 | 1285 | | |
+-------------------+----------+--------------+------------------+
1 row in set (0.00 sec)

重启MySQL服务

3、配置Slave从服务器（windows）

（1）找到MySQL安装文件夹修改my.ini文件，在[mysqld]下面增加下面几行代码


1 [mysqld]
2 server-id=2
3 relay-log-index=slave-relay-bin.index
4 relay-log=slave-relay-bin 
重启MySQL服务

（2）连接Master

change master to master_host='192.168.0.104', //Master 服务器Ip
master_port=3306,
master_user='repl',
master_password='mysql', 
master_log_file='master-bin.000001',//Master服务器产生的日志
master_log_pos=0;

（3）启动Slave

start slave;

4、Slave从服务器（Ubuntu）

（1）找到MySQL安装文件夹修改my.cnf文件,vim my.cnf

 s

 

（2） ./support-files/myql.server restart 重启MySQL服务  ,  ./bin/mysql 进入MySQL命令窗口 

（3）连接Master

change master to master_host='192.168.0.104', //Master 服务器Ip
master_port=3306,
master_user='repl',
master_password='mysql', 
master_log_file='master-bin.000001',//Master服务器产生的日志
master_log_pos=0;

（4）启动Slave

start slave;

OK所有配置都完成了，这时候大家可以在Master Mysql 中进行测试了，因为我们监视的时Master mysql  所有操作日志，所以，你的任何改变主服务器数据库的操作，都会同步到从服务器上。创建个数据库，表试试吧。。。


</body>

</html>






