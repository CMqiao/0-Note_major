<html>

<body>

<p>表单（from）的数据获取与设置。 获取表单数据 return: Object getData（formatter, deep） formatter：Boolean。默认false。设置true，获取的日期格式是&quot;2010-11-12&quot;字符串。 deep：Boolean。默认true，数据为{user:{name:&quot;111&quot;}}；设置false，数据为{&quot;user.name&quot;: &quot;111&quot;}。 设置表单数据 setData（data, all, deep） data：Object。数据对象。 all：Boolean。默认true。设置true后对表单中所有控件设置值，没有数据则清空处理。 deep：Boolean。默认false。同上。 //根据日历时间的选择，计算请假的天数 /**两个触发事件。选择开始时间时，触发方法getStarttime(); *选择结束时间时，触发方法getEndtime(); */ 开始时间： 结束时间： var stime; var etime; var days; function getStarttime(e) { var starttime=nui.get(&quot;starttime&quot;); stime=starttime.value; countdays(); } function getEndtime(e) { var endtime=nui.get(&quot;endtime&quot;); etime=endtime.value; countdays(); } function countdays(){ if(stime!=null&amp;&amp;etime!=null){ days=(etime-stime)/(24*3600*1000); var day=nui.get(&quot;days&quot;); day.setValue(days); } } //下拉框的设计实现 &lt;1&gt; 使用字典： 是否使用导师经费： &lt;2&gt; 直接定义数据： &lt;3&gt; 在页面定义对象做数据源： 婚姻状况： //页面初始加载时候调用。初始化数据。 $(function(){ var marrystates = [{ state: &quot;已婚&quot; },{ state: &quot;未婚&quot; }]; var marry = nui.get(&quot;ismarried&quot;); marry.load(marrystates); }); &lt;4&gt; 使用文件： country.txt： [{country:&quot;阿尔巴尼亚&quot;}, {country:&quot;阿尔及利亚&quot;}, {country:&quot;阿富汗&quot;}, {country:&quot;阿根廷&quot;}, {country:&quot;阿拉伯联合酋长国&quot;}, {country:&quot;阿鲁巴&quot;}, {country:&quot;阿曼&quot;}, {country:&quot;阿塞拜疆&quot;}] &lt;5&gt;除下拉框，还可以自己输入：allowInput=&quot;true&quot; &lt;6&gt;是用逻辑流返回值直接加载下拉框数据。 部门名称: nui.get(&quot;dw&quot;).load(&quot;cn.edu.shnu.common.org.org.querySecondOrgsForDicts.biz.ext&quot;); 页面加载流转相关： $(function(){ getStuInfo(); }); html文件中定义表格：</p>

<div class="nui-datagrid" id="datagrid1">
<div>
<div>序号</div>

<div>计划年份</div>

<div>年度计划名称</div>

<div>年度应参加培训总人数</div>

<div>年度计划培训总人数</div>
</div>
</div>

<p>******************************** /** * 生成&ldquo;年度应参加培训总人数&rdquo;的值 * @param o */ function onNDYCJPXZRSRenderer(o){ if(isEmptyOrZero(o.record.NDJHHZs.xmsfzrs) || isEmptyOrZero(o.record.NDJHHZs.xmsfynhzrs) || isEmptyOrZero(o.record.NDJHHZs.xmsfqtqkrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfzrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfynhzrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfqtqkrs)){ return &quot;0&quot;; } else{return &quot;111&quot;;} } /** * 生成&ldquo;年度计划培训总人数&rdquo;的值 * @param o */ function onNDJHPXZRSRenderer(o){ if(isEmptyOrZero(o.record.NDJHHZs.shjrs) || isEmptyOrZero(o.record.NDJHHZs.fshjrs)){ return &quot;0&quot;; } else{return &quot;111&quot;;} } *********************** 获取数据表格的数据信息。 var pxjh = grid.getRow(rowIndex); var data = {hzndjhid: pxjh.hzndjhid}; return data.valueOf(xmsfzrs); *********************** F12 是浏览器调试的。 *********************** 查询逻辑流最好方便别人调用，所以，criteria(查询条件)中的sql语句的参数不要指定，应该由调用的前端指定。 例如： 培训等级: 培训机构: *********************** 控制台输出信息语句：consol.log(param); *********************** nui 中，form的方法getData(boolen,boolen); 第一个控制时间格式数据的处理，第二个控制录入时，数据的深度。看mini_ui的API。 *********************** 如果前端调用后端，而一直进不了后端。用F12查看前端代码。特别是调用中的参数设置是否正确。 *********************** 文件原先可以运行，后来报错，可能是项目报-&gt;属性-&gt;依赖 没有设置。 *********************** 熟练的使用SVM版本控制器。 ********************** 系统环境配置，default数据库。在逻辑流中数据库参数，直接填写default，不然数据库变了后会出问题。 ********************** 自动生成 ********************** 构建库：构建库分四大类：数据上下文及MDO操作类，数据库操作类，EOS基础构建类，java基础构建类。 EOS帮助文档-&gt;技术参考-&gt;EOS基础构建库参考。 ********************** 注意，在前端页面书写的时候，尽量使用&quot;ALT+/&quot;提示输入。 但是有些是不会提示输出的，例如，gird.getValues ********************** 对象数组，声明一个对象数组之后，使用数组里面的每一个元素都需要先初始化。 例如：MyClass[] myclass=new MyClass[4]; for(int i=0;i&lt;4;i++){ myclass[i]=new MyClass(); myclass[i].**=i; } ********************** &lt;% %&gt; 标识里面的是jsp代码. &lt;%=变量 %&gt; 是 &lt;% out.println(变量) %&gt; 的简写方式 用户:&lt;%=username%&gt; 用户:&lt;% out.println(username) %&gt; function showReason(){ if(this.getValue()==&quot;01&quot;){ nui.get(&quot;refusedreason&quot;).setEnabled(true); }else{ nui.get(&quot;refusedreason&quot;).setEnabled(false); } } //注意这里&ldquo;this&rdquo;的使用。 //Object对象属性的获取，设置，使用set+Property(大写)? 控件对象可以尝试着使用。 //Object对象属性操作可以用&ldquo;.property&rdquo; 方式使用。</p>


常见的分库方式有水平性和垂直性。一般来说，就是按照用户属性（地市或者ID的hash）进行分库，或者按照业务功能块进行分库。 
水平分库方式主要根据用户属性（如地市）拆分物理数据库。一种常见的方式是将全省划分为几个大区。 
垂直分库方式：根据业务维度和数据的访问量等，进行数据的分离，剥离为多个数据库。例如，将一些公用的配置信息存储到一个数据库中进行单独维护。

垂直划分

按照功能划分，把数据分别放到不同的数据库和服务器。

当一个网站开始刚刚创建时，可能只是考虑一天只有几十或者几百个人访问，数据库可能就个db，所有表都放一起，一台普通的服务器可能就够了，而且开发人员也非常高兴，而且信心十足，因为所有的表都在一个库中，这样查询语句就可以随便关联了，多美的一件事情。但是随着访问压力的增加，读写操作不断增加，数据库的压力绝对越来越大，可能接近极限，这时可能人们想到增加从服务器，做什么集群之类的，可是问题又来了，数据量也快速增长。

这时可以考虑对读写操作进行分离，按照业务把不同的数据放到不同的库中。其实在一个大型而且臃肿的数据库中表和表之间的数据很多是没有关系的，或者更加不需要（join）操作，理论上就应该把他们分别放到不同的服务器。例如用户的收藏夹的数据和博客的数据库就可以放到两个独立的服务器。这个就叫垂直划分（其实叫什么不重要）。 
这里写图片描述

当博客或者收藏夹的数据不断增加后，应该怎么办，这样就引出了另外一个做法，叫水平划分。

水平划分

则把一个表的数据划分到不同的数据库，两个数据库的表结构一样。怎么划分，应该根据一定的规则，可以根据数据的产生者来做引导，上面的数据是由人产生的，可以根据人的id来划分数据库。然后再根据一定的规则，先获知数据在哪个数据库。

其实很多大型网站都经历了数据库垂直划分和水平的划分的阶段。其实这个可以根据经验来确定，不一定由某些硬性的规则。

以刚才的博客为例，数据可以根据userid的奇偶来确定数据的划分。把id为基数的放到A库，为偶数的放B库。

这里写图片描述

这样通过userId就可以知道用户的博客的数据在哪个数据库。其实可以根据userId%10来处理。还可以根据著名的Hash算法来处理。

当初看手机之家的架构是发现他们是： 
水平切分：对数据进行水平分割。

a.最好分到同一个数据库。 
b.一种已经证明是切实可行的方案：主表＋辅表。
c.有3种类型：主表不打散、主表打散无辅表、主表打散有辅表。 
d.但对程序员来说，TA看到的只是一张表，不妨称之为虚表(逻辑表)? ，这张虚表实际上可能是由N张实表(物理表)组成的。

在说句题外话，如果是大型数据库，还可以做读写分离等。

数据库读写分离


Mysql主从配置，实现读写分离

大型网站为了软解大量的并发访问，除了在网站实现分布式负载均衡，远远不够。到了数据业务层、数据访问层，如果还是传统的数据结构，或者只是单单靠一台服务器扛，如此多的数据库连接操作，数据库必然会崩溃，数据丢失的话，后果更是 不堪设想。这时候，我们会考虑如何减少数据库的联接，一方面采用优秀的代码框架，进行代码的优化，采用优秀的数据缓存技术如：memcached,如果资金丰厚的话，必然会想到假设服务器群，来分担主数据库的压力。Ok切入今天微博主题，利用MySQL主从配置，实现读写分离，减轻数据库压力。这种方式，在如今很多网站里都有使用，也不是什么新鲜事情，今天总结一下，方便大家学习参考一下。

概述：搭设一台Master服务器（win8.1系统，Ip：192.168.0.104），搭设两台Slave服务器（虚拟机——一台Ubuntu，一台 Windows Server 2003）

原理：主服务器（Master）负责网站NonQuery操作，从服务器负责Query操作，用户可以根据网站功能模特性块固定访问Slave服务器，或者自己写个池或队列，自由为请求分配从服务器连接。主从服务器利用MySQL的二进制日志文件，实现数据同步。二进制日志由主服务器产生，从服务器响应获取同步数据库。

具体实现：

1、在主从服务器上都装上MySQL数据库，windows系统鄙人安装的是mysql_5.5.25.msi版本，Ubuntu安装的是mysql-5.6.22-linux-glibc2.5-i686.tar

windows安装mysql就不谈了，一般地球人都应该会。鄙人稍微说一下Ubuntu的MySQL安装，我建议不要在线下载安装，还是离线安装的好。大家可以参考  http://www.linuxidc.com/Linux/2013-01/78716.htm 这位不知道大哥还是姐妹，写的挺好按照这个就能装上。在安装的时候可能会出现几种现象，大家可以参考解决一下：

（1）如果您不是使用root用户登录，建议 su - root 切换到Root用户安装，那就不用老是 sudo 了。

（2）存放解压的mysql 文件夹，文件夹名字最好改成mysql

（3）在./support-files/mysql.server start 启动MySQL的时候，可能会出现一个警告，中文意思是启动服务运行读文件时，忽略了my.cnf文件，那是因为my.cnf的文件权限有问题，mysql会认为该文件有危险不会执行。但是mysql还会启动成功，但如果下面配置从服务器参数修改my.cnf文件的时候，你会发现文件改过了，但是重启服务时，修改过后的配置没有执行，而且您 list一下mysql的文件夹下会发现很多.my.cnf.swp等中间文件。这都是因为MySQL启动时没有读取my.cnf的原因。这时只要将my.cnf的文件权限改成my_new.cnf的权限一样就Ok，命令：chmod 644 my.cnf就Ok



（4）Ubuntu中修改文档内容没有Vim，最好把Vim 装上，apt-get install vim,不然估计会抓狂。

这时候我相信MySQL应该安装上去了。

2、配置Master主服务器

（1）在Master MySQL上创建一个用户‘repl’，并允许其他Slave服务器可以通过远程访问Master，通过该用户读取二进制日志，实现数据同步。


复制代码
1 mysql>create user repl; //创建新用户
2 //repl用户必须具有REPLICATION SLAVE权限，除此之外没有必要添加不必要的权限，密码为mysql。说明一下192.168.0.%，这个配置是指明repl用户所在服务器，这里%是通配符，表示192.168.0.0-192.168.0.255的Server都可以以repl用户登陆主服务器。当然你也可以指定固定Ip。
3 mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.0.%' IDENTIFIED BY 'mysql';
复制代码
（2）找到MySQL安装文件夹修改my.Ini文件。mysql中有好几种日志方式，这不是今天的重点。我们只要启动二进制日志log-bin就ok。

 在[mysqld]下面增加下面几行代码


1 server-id=1   //给数据库服务的唯一标识，一般为大家设置服务器Ip的末尾号
2 log-bin=master-bin
3 log-bin-index=master-bin.index
（3）查看日志

mysql> SHOW MASTER STATUS;
+-------------------+----------+--------------+------------------+
| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+-------------------+----------+--------------+------------------+
| master-bin.000001 | 1285 | | |
+-------------------+----------+--------------+------------------+
1 row in set (0.00 sec)

重启MySQL服务

3、配置Slave从服务器（windows）

（1）找到MySQL安装文件夹修改my.ini文件，在[mysqld]下面增加下面几行代码


1 [mysqld]
2 server-id=2
3 relay-log-index=slave-relay-bin.index
4 relay-log=slave-relay-bin 
重启MySQL服务

（2）连接Master

change master to master_host='192.168.0.104', //Master 服务器Ip
master_port=3306,
master_user='repl',
master_password='mysql', 
master_log_file='master-bin.000001',//Master服务器产生的日志
master_log_pos=0;

（3）启动Slave

start slave;

4、Slave从服务器（Ubuntu）

（1）找到MySQL安装文件夹修改my.cnf文件,vim my.cnf

 s

 

（2） ./support-files/myql.server restart 重启MySQL服务  ,  ./bin/mysql 进入MySQL命令窗口 

（3）连接Master

change master to master_host='192.168.0.104', //Master 服务器Ip
master_port=3306,
master_user='repl',
master_password='mysql', 
master_log_file='master-bin.000001',//Master服务器产生的日志
master_log_pos=0;

（4）启动Slave

start slave;

OK所有配置都完成了，这时候大家可以在Master Mysql 中进行测试了，因为我们监视的时Master mysql  所有操作日志，所以，你的任何改变主服务器数据库的操作，都会同步到从服务器上。创建个数据库，表试试吧。。。







###


Java 并发开发:Lock 框架详解
2017-11-25 java面试笔试
摘要：

我们已经知道，synchronized 是java的关键字，是Java的内置特性，在JVM层面实现了对临界资源的同步互斥访问，但 synchronized 粒度有些大，在处理实际问题时存在诸多局限性，比如响应中断等。Lock 提供了比 synchronized更广泛的锁操作，它能以更优雅的方式处理线程同步问题。本文以synchronized与Lock的对比为切入点，对Java中的Lock框架的枝干部分进行了详细介绍，最后给出了锁的一些相关概念。

一. synchronized 的局限性 与 Lock 的优点

回顾文章《Java 并发：内置锁 Synchronized》，如果一个代码块被synchronized关键字修饰，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待直至占有锁的线程释放锁。事实上，占有锁的线程释放锁一般会是以下三种情况之一：

占有锁的线程执行完了该代码块，然后释放对锁的占有；
占有锁线程执行发生异常，此时JVM会让线程自动释放锁；
占有锁线程进入 WAITING 状态从而释放锁，例如在该线程中调用wait()方法等。
synchronized 是Java语言的内置特性，可以轻松实现对临界资源的同步互斥访问。那么，为什么还会出现Lock呢？试考虑以下三种情况：

Case 1 ：

在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间 (解决方案：tryLock(long time, TimeUnit unit)) 或者 能够响应中断 (解决方案：lockInterruptibly())），这种情况可以通过 Lock 解决。

Case 2 ：

我们知道，当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程都只是进行读操作时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。同样地，Lock也可以解决这种情况 (解决方案：ReentrantReadWriteLock) 。

Case 3 ：

我们可以通过Lock得知线程有没有成功获取到锁 (解决方案：ReentrantLock) ，但这个是synchronized无法办到的。

上面提到的三种情形，我们都可以通过Lock来解决，但 synchronized 关键字却无能为力。事实上，Lock 是 java.util.concurrent.locks包 下的接口，Lock 实现提供了比 synchronized 关键字 更广泛的锁操作，它能以更优雅的方式处理线程同步问题。也就是说，Lock提供了比synchronized更多的功能。但是要注意以下几点：

1）synchronized是Java的关键字，因此是Java的内置特性，是基于JVM层面实现的。而Lock是一个Java接口，是基于JDK层面实现的，通过这个接口可以实现同步访问；

2）采用synchronized方式不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致死锁现象。

二. java.util.concurrent.locks包下常用的类与接口

以下是 java.util.concurrent.locks包下主要常用的类与接口的关系：



1、Lock

通过查看Lock的源码可知，Lock 是一个接口：


下面来逐个分析Lock接口中每个方法。lock()、tryLock()、tryLock(long time, TimeUnit unit) 和 lockInterruptibly()都是用来获取锁的。unLock()方法是用来释放锁的。newCondition() 返回 绑定到此 Lock 的新的 Condition 实例 ，用于线程间的协作，详细内容见文章《Java 并发：线程间通信与协作》。

1). lock()

在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？首先，lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。在前面已经讲到，如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此，一般来说，使用Lock必须在try…catch…块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：


2). tryLock() & tryLock(long time, TimeUnit unit)

tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true；如果获取失败（即锁已被其他线程获取），则返回false，也就是说，这个方法无论如何都会立即返回（在拿不到锁时不会一直在那等待）。

tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false，同时可以响应中断。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。

一般情况下，通过tryLock来获取锁时是这样使用的：


3). lockInterruptibly()

lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程 正在等待获取锁，则这个线程能够 响应中断，即中断线程的等待状态。例如，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。

由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出 InterruptedException，但推荐使用后者，原因稍后阐述。因此，lockInterruptibly()一般的使用形式如下：


注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为interrupt()方法只能中断阻塞过程中的线程而不能中断正在运行过程中的线程。因此，当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，那么只有进行等待的情况下，才可以响应中断的。与 synchronized 相比，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。

2、ReentrantLock

ReentrantLock，即 可重入锁。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例学习如何使用 ReentrantLock。

例 1 ： Lock 的正确使用



结果或许让人觉得诧异。第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么每个线程执行到lock.lock()处获取的是不同的锁，所以就不会对临界资源形成同步互斥访问。因此，我们只需要将lock声明为成员变量即可，如下所示。

例 2 ： tryLock() & tryLock(long time, TimeUnit unit)


与 tryLock() 不同的是，tryLock(long time, TimeUnit unit) 能够响应中断，即支持对获取锁的中断，但尝试获取一个内部锁的操作（进入一个 synchronized 块）是不能被中断的。如下所示：



例 3 ： 使用 lockInterruptibly() 响应中断



运行上述代码之后，发现 thread2 能够被正确中断，放弃对任务的执行。特别需要注意的是，如果需要正确中断等待锁的线程，必须将获取锁放在外面（try 语句块外），然后将 InterruptedException 抛出。如果不这样做，像如下代码所示：



注意，上述代码就将锁的获取操作放在try语句块里，则必定会执行finally语句块中的解锁操作。在 准备获取锁的 线程B 被中断后，再执行解锁操作就会抛出 IllegalMonitorStateException，因为该线程并未获得到锁却执行了解锁操作。

3、ReadWriteLock

ReadWriteLock也是一个接口，在它里面只定义了两个方法：


一个用来获取读锁，一个用来获取写锁。也就是说，将对临界资源的读写操作分成两个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的 ReentrantReadWriteLock 实现了 ReadWriteLock 接口。

4、ReentrantReadWriteLock

ReentrantReadWriteLock 里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。下面通过几个例子来看一下ReentrantReadWriteLock具体用法。假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：


这段程序的输出结果会是，直到线程A执行完读操作之后，才会打印线程B执行读操作的信息。而改成使用读写锁的话：



我们可以看到，线程A和线程B在同时进行读操作，这样就大大提升了读操作的效率。不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程也会一直等待释放写锁。

5、Lock和synchronized的选择

总的来说，Lock和synchronized有以下几点不同：

(1) Lock是一个接口，是JDK层面的实现；而synchronized是Java中的关键字，是Java的内置特性，是JVM层面的实现；
(2) synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
(3) Lock 可以让等待锁的线程响应中断，而使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
(4) 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到；
(5) Lock可以提高多个线程进行读操作的效率。
在性能上来说，如果竞争资源不激烈，两者的性能是差不多的。而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

三. 锁的相关概念介绍

1、可重入锁

如果锁具备可重入性，则称作为 可重入锁 。像 synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了 锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。


上述代码中的两个方法method1和method2都用synchronized修饰了。假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是，这就会造成死锁，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。

2、可中断锁

顾名思义，可中断锁就是可以响应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。
如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。在前面演示tryLock(long time, TimeUnit unit)和lockInterruptibly()的用法时已经体现了Lock的可中断性。

3、公平锁

公平锁即 尽量 以请求锁的顺序来获取锁。比如，同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。而非公平锁则无法保证锁的获取是按照请求锁的顺序进行的，这样就可能导致某个或者一些线程永远获取不到锁。

在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock 和 ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。

看下面两个例子：

Case : 公平锁



Case: 非公平锁


根据上面代码演示结果我们可以看出（线程数越多越明显），在公平锁案例下，多个线程在等待一个锁时，一般而言，等待时间最久的线程（最先请求的线程）会获得该锁。而在非公平锁例下，则无法保证锁的获取是按照请求锁的顺序进行的。

另外， 在ReentrantLock类中定义了很多方法，举几个例子：

isFair() //判断锁是否是公平锁
isLocked() //判断锁是否被任何线程获取了
isHeldByCurrentThread() //判断锁是否被当前线程获取了
hasQueuedThreads() //判断是否有线程在等待该锁
getHoldCount() //查询当前线程占有lock锁的次数
getQueueLength() // 获取正在等待此锁的线程数
getWaitQueueLength(Condition condition) // 获取正在等待此锁相关条件condition的线程数在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。
4.读写锁

读写锁将对临界资源的访问分成了两个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。上一节已经演示过了读写锁的使用方法，在此不再赘述。

</body>

</html>






