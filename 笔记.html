<html>

<body>

<p>表单（from）的数据获取与设置。 获取表单数据 return: Object getData（formatter, deep） formatter：Boolean。默认false。设置true，获取的日期格式是&quot;2010-11-12&quot;字符串。 deep：Boolean。默认true，数据为{user:{name:&quot;111&quot;}}；设置false，数据为{&quot;user.name&quot;: &quot;111&quot;}。 设置表单数据 setData（data, all, deep） data：Object。数据对象。 all：Boolean。默认true。设置true后对表单中所有控件设置值，没有数据则清空处理。 deep：Boolean。默认false。同上。 //根据日历时间的选择，计算请假的天数 /**两个触发事件。选择开始时间时，触发方法getStarttime(); *选择结束时间时，触发方法getEndtime(); */ 开始时间： 结束时间： var stime; var etime; var days; function getStarttime(e) { var starttime=nui.get(&quot;starttime&quot;); stime=starttime.value; countdays(); } function getEndtime(e) { var endtime=nui.get(&quot;endtime&quot;); etime=endtime.value; countdays(); } function countdays(){ if(stime!=null&amp;&amp;etime!=null){ days=(etime-stime)/(24*3600*1000); var day=nui.get(&quot;days&quot;); day.setValue(days); } } //下拉框的设计实现 &lt;1&gt; 使用字典： 是否使用导师经费： &lt;2&gt; 直接定义数据： &lt;3&gt; 在页面定义对象做数据源： 婚姻状况： //页面初始加载时候调用。初始化数据。 $(function(){ var marrystates = [{ state: &quot;已婚&quot; },{ state: &quot;未婚&quot; }]; var marry = nui.get(&quot;ismarried&quot;); marry.load(marrystates); }); &lt;4&gt; 使用文件： country.txt： [{country:&quot;阿尔巴尼亚&quot;}, {country:&quot;阿尔及利亚&quot;}, {country:&quot;阿富汗&quot;}, {country:&quot;阿根廷&quot;}, {country:&quot;阿拉伯联合酋长国&quot;}, {country:&quot;阿鲁巴&quot;}, {country:&quot;阿曼&quot;}, {country:&quot;阿塞拜疆&quot;}] &lt;5&gt;除下拉框，还可以自己输入：allowInput=&quot;true&quot; &lt;6&gt;是用逻辑流返回值直接加载下拉框数据。 部门名称: nui.get(&quot;dw&quot;).load(&quot;cn.edu.shnu.common.org.org.querySecondOrgsForDicts.biz.ext&quot;); 页面加载流转相关： $(function(){ getStuInfo(); }); html文件中定义表格：</p>

<div class="nui-datagrid" id="datagrid1">
<div>
<div>序号</div>

<div>计划年份</div>

<div>年度计划名称</div>

<div>年度应参加培训总人数</div>

<div>年度计划培训总人数</div>
</div>
</div>

<p>******************************** /** * 生成&ldquo;年度应参加培训总人数&rdquo;的值 * @param o */ function onNDYCJPXZRSRenderer(o){ if(isEmptyOrZero(o.record.NDJHHZs.xmsfzrs) || isEmptyOrZero(o.record.NDJHHZs.xmsfynhzrs) || isEmptyOrZero(o.record.NDJHHZs.xmsfqtqkrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfzrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfynhzrs) || isEmptyOrZero(o.record.NDJHHZs.jxsfqtqkrs)){ return &quot;0&quot;; } else{return &quot;111&quot;;} } /** * 生成&ldquo;年度计划培训总人数&rdquo;的值 * @param o */ function onNDJHPXZRSRenderer(o){ if(isEmptyOrZero(o.record.NDJHHZs.shjrs) || isEmptyOrZero(o.record.NDJHHZs.fshjrs)){ return &quot;0&quot;; } else{return &quot;111&quot;;} } *********************** 获取数据表格的数据信息。 var pxjh = grid.getRow(rowIndex); var data = {hzndjhid: pxjh.hzndjhid}; return data.valueOf(xmsfzrs); *********************** F12 是浏览器调试的。 *********************** 查询逻辑流最好方便别人调用，所以，criteria(查询条件)中的sql语句的参数不要指定，应该由调用的前端指定。 例如： 培训等级: 培训机构: *********************** 控制台输出信息语句：consol.log(param); *********************** nui 中，form的方法getData(boolen,boolen); 第一个控制时间格式数据的处理，第二个控制录入时，数据的深度。看mini_ui的API。 *********************** 如果前端调用后端，而一直进不了后端。用F12查看前端代码。特别是调用中的参数设置是否正确。 *********************** 文件原先可以运行，后来报错，可能是项目报-&gt;属性-&gt;依赖 没有设置。 *********************** 熟练的使用SVM版本控制器。 ********************** 系统环境配置，default数据库。在逻辑流中数据库参数，直接填写default，不然数据库变了后会出问题。 ********************** 自动生成 ********************** 构建库：构建库分四大类：数据上下文及MDO操作类，数据库操作类，EOS基础构建类，java基础构建类。 EOS帮助文档-&gt;技术参考-&gt;EOS基础构建库参考。 ********************** 注意，在前端页面书写的时候，尽量使用&quot;ALT+/&quot;提示输入。 但是有些是不会提示输出的，例如，gird.getValues ********************** 对象数组，声明一个对象数组之后，使用数组里面的每一个元素都需要先初始化。 例如：MyClass[] myclass=new MyClass[4]; for(int i=0;i&lt;4;i++){ myclass[i]=new MyClass(); myclass[i].**=i; } ********************** &lt;% %&gt; 标识里面的是jsp代码. &lt;%=变量 %&gt; 是 &lt;% out.println(变量) %&gt; 的简写方式 用户:&lt;%=username%&gt; 用户:&lt;% out.println(username) %&gt; function showReason(){ if(this.getValue()==&quot;01&quot;){ nui.get(&quot;refusedreason&quot;).setEnabled(true); }else{ nui.get(&quot;refusedreason&quot;).setEnabled(false); } } //注意这里&ldquo;this&rdquo;的使用。 //Object对象属性的获取，设置，使用set+Property(大写)? 控件对象可以尝试着使用。 //Object对象属性操作可以用&ldquo;.property&rdquo; 方式使用。</p>

</body>

</html>



168、什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？ 
答： 
- XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 
- SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。 
- CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。

补充：防火墙的架设是Web安全的重要保障，ModSecurity是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。



