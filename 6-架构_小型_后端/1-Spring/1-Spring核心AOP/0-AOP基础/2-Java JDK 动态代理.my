<h1>Java JDK 动态代理（AOP）使用及实现原理分析</h1>

<p>&nbsp;</p>

<h2>一、什么是代理？</h2>

<p><a href="http://blog.csdn.net/jiankunking/article/details/52143504">原文链接</a></p>

<p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>

<p>代理模式UML图：</p>

<p><img alt="" src="http://img.blog.csdn.net/20160807170246461?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p>简单结构示意图：</p>

<p><img alt="" src="http://img.blog.csdn.net/20160810080241992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。<a href="http://lib.csdn.net/base/java" target="_blank" title="Java 知识库">Java</a> 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。</p>

<h2>二、Java 动态代理类&nbsp;</h2>

<p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：</p>

<p>(1)Interface InvocationHandler：该接口中仅定义了一个方法</p>

<ol start="1">
	<li>publicobject&nbsp;invoke(Object&nbsp;obj,Method&nbsp;method,&nbsp;Object[]&nbsp;args)&nbsp;&nbsp;</li>
</ol>

<p>在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组。这个抽象方法在代理类中动态实现。</p>

<p>(2)Proxy：该类即为动态代理类，其中主要包含以下内容：</p>

<p>&nbsp;</p>

<p>protected Proxy(InvocationHandler&nbsp;h)：构造函数，用于给内部的h赋值。</p>

<p>static Class&nbsp;getProxyClass&nbsp;(ClassLoaderloader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。</p>

<p>static Object&nbsp;newProxyInstance(ClassLoaderloader, Class[] interfaces,&nbsp;InvocationHandler&nbsp;h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)</p>

<p>&nbsp;</p>

<p>所谓DynamicProxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些&nbsp;interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</p>

<p>&nbsp;</p>

<p>在使用动态代理类时，我们必须实现InvocationHandler接口</p>

<p>&nbsp;</p>

<p>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。</p>

<p><strong>动态代理步骤</strong>：<br />
1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法<br />
2.创建被代理的类以及接口<br />
3.通过Proxy的静态方法<br />
newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理<br />
4.通过代理调用方法</p>

<p>&nbsp;</p>

<h2>三、JDK的动态代理怎么使用？</h2>

<p>1、需要动态代理的接口：</p>

<ol start="1">
	<li>package&nbsp;jiankunking;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>/**&nbsp;</li>
	<li>&nbsp;*&nbsp;需要动态代理的接口&nbsp;</li>
	<li>&nbsp;*/&nbsp;&nbsp;</li>
	<li>public&nbsp;interface&nbsp;Subject&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;你好&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;name&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;SayHello(String&nbsp;name);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;再见&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;SayGoodBye();&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p><br />
2、需要代理的实际对象</p>

<ol start="1">
	<li>package&nbsp;jiankunking;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>/**&nbsp;</li>
	<li>&nbsp;*&nbsp;实际对象&nbsp;</li>
	<li>&nbsp;*/&nbsp;&nbsp;</li>
	<li>public&nbsp;class&nbsp;RealSubject&nbsp;implements&nbsp;Subject&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;你好&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;name&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;SayHello(String&nbsp;name)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;hello&nbsp;&quot;&nbsp;+&nbsp;name;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;再见&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;SayGoodBye()&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;&nbsp;good&nbsp;bye&nbsp;&quot;;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p><br />
3、调用处理器实现类（有木有感觉这里就是传说中的AOP啊）</p>

<ol start="1">
	<li>package&nbsp;jiankunking;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.InvocationHandler;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.Method;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>/**&nbsp;</li>
	<li>&nbsp;*&nbsp;调用处理器实现类&nbsp;</li>
	<li>&nbsp;*&nbsp;每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象&nbsp;</li>
	<li>&nbsp;*/&nbsp;&nbsp;</li>
	<li>public&nbsp;class&nbsp;InvocationHandlerImpl&nbsp;implements&nbsp;InvocationHandler&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;这个就是我们要代理的真实对象&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Object&nbsp;subject;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;构造方法，给我们要代理的真实对象赋初值&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;subject&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;InvocationHandlerImpl(Object&nbsp;subject)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.subject&nbsp;=&nbsp;subject;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;该方法负责集中处理动态代理类上的所有方法调用。&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;proxy&nbsp;&nbsp;代理类实例&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;method&nbsp;被调用的方法对象&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;args&nbsp;&nbsp;&nbsp;调用参数&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@throws&nbsp;Throwable&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Object&nbsp;invoke(Object&nbsp;proxy,&nbsp;Method&nbsp;method,&nbsp;Object[]&nbsp;args)&nbsp;throws&nbsp;Throwable&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在代理真实对象前我们可以添加一些自己的操作&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;在调用之前，我要干点啥呢？&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Method:&quot;&nbsp;+&nbsp;method);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;returnValue&nbsp;=&nbsp;method.invoke(subject,&nbsp;args);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在代理真实对象后我们也可以添加一些自己的操作&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;在调用之后，我要干点啥呢？&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;returnValue;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>4、测试</p>

<ol start="1">
	<li>package&nbsp;jiankunking;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.InvocationHandler;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.Proxy;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>/**&nbsp;</li>
	<li>&nbsp;*&nbsp;动态代理演示&nbsp;</li>
	<li>&nbsp;*/&nbsp;&nbsp;</li>
	<li>public&nbsp;class&nbsp;DynamicProxyDemonstration&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//代理的真实对象&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;realSubject&nbsp;=&nbsp;new&nbsp;RealSubject();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;InvocationHandlerImpl&nbsp;实现了&nbsp;InvocationHandler&nbsp;接口，并能实现方法调用从代理类到委托类的分派转发&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InvocationHandler&nbsp;handler&nbsp;=&nbsp;new&nbsp;InvocationHandlerImpl(realSubject);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassLoader&nbsp;loader&nbsp;=&nbsp;realSubject.getClass().getClassLoader();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class[]&nbsp;interfaces&nbsp;=&nbsp;realSubject.getClass().getInterfaces();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;subject&nbsp;=&nbsp;(Subject)&nbsp;Proxy.newProxyInstance(loader,&nbsp;interfaces,&nbsp;handler);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;动态代理对象的类型：&quot;+subject.getClass().getName());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;hello&nbsp;=&nbsp;subject.SayHello(&quot;jiankunking&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(hello);&nbsp;&nbsp;</li>
	<li>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;goodbye&nbsp;=&nbsp;subject.SayGoodBye();&nbsp;&nbsp;</li>
	<li>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(goodbye);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>5、输出结果如下：</p>

<p>&nbsp;</p>

<p><img alt="" src="http://img.blog.csdn.net/20160807170853562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p>演示demo下载地址：<a href="http://download.csdn.net/detail/xunzaosiyecao/9597388" target="_blank">http://download.csdn.net/detail/xunzaosiyecao/9597388</a></p>

<h2>四、动态代理怎么实现的？</h2>

<p>从使用代码中可以看出，关键点在：</p>

<ol start="1">
	<li>Subject&nbsp;subject&nbsp;=&nbsp;(Subject)&nbsp;Proxy.newProxyInstance(loader,&nbsp;interfaces,&nbsp;handler);&nbsp;&nbsp;</li>
</ol>

<p>通过跟踪提示代码可以看出：当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用。</p>

<p>也就是说，当代码执行到：</p>

<p>subject.SayHello(<strong>&quot;jiankunking&quot;</strong>)这句话时，会自动调用InvocationHandlerImpl的invoke方法。这是为啥呢？</p>

<p>&nbsp;</p>

<p>======================横线之间的是代码跟分析的过程，不想看的朋友可以直接看结论=====================================</p>

<p>以下代码来自:JDK1.8.0_92</p>

<p>既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？&nbsp;</p>

<ol start="1">
	<li>/**&nbsp;</li>
	<li>&nbsp;*&nbsp;Returns&nbsp;an&nbsp;instance&nbsp;of&nbsp;a&nbsp;proxy&nbsp;class&nbsp;for&nbsp;the&nbsp;specified&nbsp;interfaces&nbsp;</li>
	<li>&nbsp;*&nbsp;that&nbsp;dispatches&nbsp;method&nbsp;invocations&nbsp;to&nbsp;the&nbsp;specified&nbsp;invocation&nbsp;</li>
	<li>&nbsp;*&nbsp;handler.&nbsp;</li>
	<li>&nbsp;*&nbsp;</li>
	<li>&nbsp;*&nbsp;&lt;p&gt;{@code&nbsp;Proxy.newProxyInstance}&nbsp;throws&nbsp;</li>
	<li>&nbsp;*&nbsp;{@code&nbsp;IllegalArgumentException}&nbsp;for&nbsp;the&nbsp;same&nbsp;reasons&nbsp;that&nbsp;</li>
	<li>&nbsp;*&nbsp;{@code&nbsp;Proxy.getProxyClass}&nbsp;does.&nbsp;</li>
	<li>&nbsp;*&nbsp;</li>
	<li>&nbsp;*&nbsp;@param&nbsp;&nbsp;&nbsp;loader&nbsp;the&nbsp;class&nbsp;loader&nbsp;to&nbsp;define&nbsp;the&nbsp;proxy&nbsp;class&nbsp;</li>
	<li>&nbsp;*&nbsp;@param&nbsp;&nbsp;&nbsp;interfaces&nbsp;the&nbsp;list&nbsp;of&nbsp;interfaces&nbsp;for&nbsp;the&nbsp;proxy&nbsp;class&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;implement&nbsp;</li>
	<li>&nbsp;*&nbsp;@param&nbsp;&nbsp;&nbsp;h&nbsp;the&nbsp;invocation&nbsp;handler&nbsp;to&nbsp;dispatch&nbsp;method&nbsp;invocations&nbsp;to&nbsp;</li>
	<li>&nbsp;*&nbsp;@return&nbsp;&nbsp;a&nbsp;proxy&nbsp;instance&nbsp;with&nbsp;the&nbsp;specified&nbsp;invocation&nbsp;handler&nbsp;of&nbsp;a&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy&nbsp;class&nbsp;that&nbsp;is&nbsp;defined&nbsp;by&nbsp;the&nbsp;specified&nbsp;class&nbsp;loader&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;that&nbsp;implements&nbsp;the&nbsp;specified&nbsp;interfaces&nbsp;</li>
	<li>&nbsp;*&nbsp;@throws&nbsp;&nbsp;IllegalArgumentException&nbsp;if&nbsp;any&nbsp;of&nbsp;the&nbsp;restrictions&nbsp;on&nbsp;the&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters&nbsp;that&nbsp;may&nbsp;be&nbsp;passed&nbsp;to&nbsp;{@code&nbsp;getProxyClass}&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;violated&nbsp;</li>
	<li>&nbsp;*&nbsp;@throws&nbsp;&nbsp;SecurityException&nbsp;if&nbsp;a&nbsp;security&nbsp;manager,&nbsp;&lt;em&gt;s&lt;/em&gt;,&nbsp;is&nbsp;present&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;any&nbsp;of&nbsp;the&nbsp;following&nbsp;conditions&nbsp;is&nbsp;met:&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt;&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&nbsp;the&nbsp;given&nbsp;{@code&nbsp;loader}&nbsp;is&nbsp;{@code&nbsp;null}&nbsp;and&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;caller&#39;s&nbsp;class&nbsp;loader&nbsp;is&nbsp;not&nbsp;{@code&nbsp;null}&nbsp;and&nbsp;the&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invocation&nbsp;of&nbsp;{@link&nbsp;SecurityManager#checkPermission&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.checkPermission}&nbsp;with&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@code&nbsp;RuntimePermission(&quot;getClassLoader&quot;)}&nbsp;permission&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denies&nbsp;access;&lt;/li&gt;&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&nbsp;for&nbsp;each&nbsp;proxy&nbsp;interface,&nbsp;{@code&nbsp;intf},&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;caller&#39;s&nbsp;class&nbsp;loader&nbsp;is&nbsp;not&nbsp;the&nbsp;same&nbsp;as&nbsp;or&nbsp;an&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ancestor&nbsp;of&nbsp;the&nbsp;class&nbsp;loader&nbsp;for&nbsp;{@code&nbsp;intf}&nbsp;and&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invocation&nbsp;of&nbsp;{@link&nbsp;SecurityManager#checkPackageAccess&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.checkPackageAccess()}&nbsp;denies&nbsp;access&nbsp;to&nbsp;{@code&nbsp;intf};&lt;/li&gt;&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&nbsp;any&nbsp;of&nbsp;the&nbsp;given&nbsp;proxy&nbsp;interfaces&nbsp;is&nbsp;non-public&nbsp;and&nbsp;the&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caller&nbsp;class&nbsp;is&nbsp;not&nbsp;in&nbsp;the&nbsp;same&nbsp;{@linkplain&nbsp;Package&nbsp;runtime&nbsp;package}&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;the&nbsp;non-public&nbsp;interface&nbsp;and&nbsp;the&nbsp;invocation&nbsp;of&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@link&nbsp;SecurityManager#checkPermission&nbsp;s.checkPermission}&nbsp;with&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@code&nbsp;ReflectPermission(&quot;newProxyInPackage.{package&nbsp;name}&quot;)}&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;permission&nbsp;denies&nbsp;access.&lt;/li&gt;&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;&nbsp;</li>
	<li>&nbsp;*&nbsp;@throws&nbsp;&nbsp;NullPointerException&nbsp;if&nbsp;the&nbsp;{@code&nbsp;interfaces}&nbsp;array&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argument&nbsp;or&nbsp;any&nbsp;of&nbsp;its&nbsp;elements&nbsp;are&nbsp;{@code&nbsp;null},&nbsp;or&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;the&nbsp;invocation&nbsp;handler,&nbsp;{@code&nbsp;h},&nbsp;is&nbsp;</li>
	<li>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@code&nbsp;null}&nbsp;</li>
	<li>&nbsp;*/&nbsp;&nbsp;</li>
	<li>@CallerSensitive&nbsp;&nbsp;&nbsp;</li>
	<li>public&nbsp;static&nbsp;Object&nbsp;newProxyInstance(ClassLoader&nbsp;loader,&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt;[]&nbsp;interfaces,&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InvocationHandler&nbsp;h)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;IllegalArgumentException&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//检查h&nbsp;不为空，否则抛异常&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objects.requireNonNull(h);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Class&lt;?&gt;[]&nbsp;intfs&nbsp;=&nbsp;interfaces.clone();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;SecurityManager&nbsp;sm&nbsp;=&nbsp;System.getSecurityManager();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sm&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkProxyAccess(Reflection.getCallerClass(),&nbsp;loader,&nbsp;intfs);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;获得与指定类装载器和一组接口相关的代理类类型对象&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt;&nbsp;cl&nbsp;=&nbsp;getProxyClass0(loader,&nbsp;intfs);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;通过反射获取构造函数对象并生成代理类实例&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sm&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkNewProxyPermission(Reflection.getCallerClass(),&nbsp;cl);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取代理对象的构造方法（也就是$Proxy0(InvocationHandler&nbsp;h)）&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Constructor&lt;?&gt;&nbsp;cons&nbsp;=&nbsp;cl.getConstructor(constructorParams);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;InvocationHandler&nbsp;ih&nbsp;=&nbsp;h;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!Modifier.isPublic(cl.getModifiers()))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AccessController.doPrivileged(new&nbsp;PrivilegedAction&lt;Void&gt;()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cons.setAccessible(true);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生成代理类的实例并把InvocationHandlerImpl的实例传给它的构造方法&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cons.newInstance(new&nbsp;Object[]{h});&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IllegalAccessException|InstantiationException&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;InternalError(e.toString(),&nbsp;e);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InvocationTargetException&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throwable&nbsp;t&nbsp;=&nbsp;e.getCause();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t&nbsp;instanceof&nbsp;RuntimeException)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RuntimeException)&nbsp;t;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;InternalError(t.toString(),&nbsp;t);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(NoSuchMethodException&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;InternalError(e.toString(),&nbsp;e);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
&nbsp;</p>

<p>我们再进去getProxyClass0方法看一下：</p>

<ol start="1">
	<li>/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Generate&nbsp;a&nbsp;proxy&nbsp;class.&nbsp;&nbsp;Must&nbsp;call&nbsp;the&nbsp;checkProxyAccess&nbsp;method&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;to&nbsp;perform&nbsp;permission&nbsp;checks&nbsp;before&nbsp;calling&nbsp;this.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Class&lt;?&gt;&nbsp;getProxyClass0(ClassLoader&nbsp;loader,&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt;...&nbsp;interfaces)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(interfaces.length&nbsp;&gt;&nbsp;65535)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(&quot;interface&nbsp;limit&nbsp;exceeded&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;the&nbsp;proxy&nbsp;class&nbsp;defined&nbsp;by&nbsp;the&nbsp;given&nbsp;loader&nbsp;implementing&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;given&nbsp;interfaces&nbsp;exists,&nbsp;this&nbsp;will&nbsp;simply&nbsp;return&nbsp;the&nbsp;cached&nbsp;copy;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;otherwise,&nbsp;it&nbsp;will&nbsp;create&nbsp;the&nbsp;proxy&nbsp;class&nbsp;via&nbsp;the&nbsp;ProxyClassFactory&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;proxyClassCache.get(loader,&nbsp;interfaces);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p>真相还是没有来到，继续，看一下proxyClassCache</p>

<ol start="1">
	<li>/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;a&nbsp;cache&nbsp;of&nbsp;proxy&nbsp;classes&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;WeakCache&lt;ClassLoader,&nbsp;Class&lt;?&gt;[],&nbsp;Class&lt;?&gt;&gt;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxyClassCache&nbsp;=&nbsp;new&nbsp;WeakCache&lt;&gt;(new&nbsp;KeyFactory(),&nbsp;new&nbsp;ProxyClassFactory());&nbsp;&nbsp;</li>
</ol>

<p>奥，原来用了一下缓存啊</p>

<p>那么它对应的get方法啥样呢？</p>

<ol start="1">
	<li>/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Look-up&nbsp;the&nbsp;value&nbsp;through&nbsp;the&nbsp;cache.&nbsp;This&nbsp;always&nbsp;evaluates&nbsp;the&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;{@code&nbsp;subKeyFactory}&nbsp;function&nbsp;and&nbsp;optionally&nbsp;evaluates&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;{@code&nbsp;valueFactory}&nbsp;function&nbsp;if&nbsp;there&nbsp;is&nbsp;no&nbsp;entry&nbsp;in&nbsp;the&nbsp;cache&nbsp;for&nbsp;given&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;pair&nbsp;of&nbsp;(key,&nbsp;subKey)&nbsp;or&nbsp;the&nbsp;entry&nbsp;has&nbsp;already&nbsp;been&nbsp;cleared.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibly&nbsp;null&nbsp;key&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;parameter&nbsp;parameter&nbsp;used&nbsp;together&nbsp;with&nbsp;key&nbsp;to&nbsp;create&nbsp;sub-key&nbsp;and&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;(should&nbsp;not&nbsp;be&nbsp;null)&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;the&nbsp;cached&nbsp;value&nbsp;(never&nbsp;null)&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@throws&nbsp;NullPointerException&nbsp;if&nbsp;{@code&nbsp;parameter}&nbsp;passed&nbsp;in&nbsp;or&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@code&nbsp;sub-key}&nbsp;calculated&nbsp;by&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@code&nbsp;subKeyFactory}&nbsp;or&nbsp;{@code&nbsp;value}&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculated&nbsp;by&nbsp;{@code&nbsp;valueFactory}&nbsp;is&nbsp;null.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;public&nbsp;V&nbsp;get(K&nbsp;key,&nbsp;P&nbsp;parameter)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Objects.requireNonNull(parameter);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expungeStaleEntries();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;cacheKey&nbsp;=&nbsp;CacheKey.valueOf(key,&nbsp;refQueue);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;lazily&nbsp;install&nbsp;the&nbsp;2nd&nbsp;level&nbsp;valuesMap&nbsp;for&nbsp;the&nbsp;particular&nbsp;cacheKey&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentMap&lt;Object,&nbsp;Supplier&lt;V&gt;&gt;&nbsp;valuesMap&nbsp;=&nbsp;map.get(cacheKey);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(valuesMap&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//putIfAbsent这个方法在key不存在的时候加入一个值,如果key存在就不放入&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentMap&lt;Object,&nbsp;Supplier&lt;V&gt;&gt;&nbsp;oldValuesMap&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;map.putIfAbsent(cacheKey,&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuesMap&nbsp;=&nbsp;new&nbsp;ConcurrentHashMap&lt;&gt;());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(oldValuesMap&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuesMap&nbsp;=&nbsp;oldValuesMap;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;subKey&nbsp;and&nbsp;retrieve&nbsp;the&nbsp;possible&nbsp;Supplier&lt;V&gt;&nbsp;stored&nbsp;by&nbsp;that&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;subKey&nbsp;from&nbsp;valuesMap&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;subKey&nbsp;=&nbsp;Objects.requireNonNull(subKeyFactory.apply(key,&nbsp;parameter));&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supplier&lt;V&gt;&nbsp;supplier&nbsp;=&nbsp;valuesMap.get(subKey);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Factory&nbsp;factory&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(supplier&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;supplier&nbsp;might&nbsp;be&nbsp;a&nbsp;Factory&nbsp;or&nbsp;a&nbsp;CacheValue&lt;V&gt;&nbsp;instance&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;value&nbsp;=&nbsp;supplier.get();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(value&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;else&nbsp;no&nbsp;supplier&nbsp;in&nbsp;cache&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;or&nbsp;a&nbsp;supplier&nbsp;that&nbsp;returned&nbsp;null&nbsp;(could&nbsp;be&nbsp;a&nbsp;cleared&nbsp;CacheValue&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;or&nbsp;a&nbsp;Factory&nbsp;that&nbsp;wasn&#39;t&nbsp;successful&nbsp;in&nbsp;installing&nbsp;the&nbsp;CacheValue)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;lazily&nbsp;construct&nbsp;a&nbsp;Factory&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(factory&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factory&nbsp;=&nbsp;new&nbsp;Factory(key,&nbsp;parameter,&nbsp;subKey,&nbsp;valuesMap);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(supplier&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supplier&nbsp;=&nbsp;valuesMap.putIfAbsent(subKey,&nbsp;factory);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(supplier&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;successfully&nbsp;installed&nbsp;Factory&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supplier&nbsp;=&nbsp;factory;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;else&nbsp;retry&nbsp;with&nbsp;winning&nbsp;supplier&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(valuesMap.replace(subKey,&nbsp;supplier,&nbsp;factory))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;successfully&nbsp;replaced&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;cleared&nbsp;CacheEntry&nbsp;/&nbsp;unsuccessful&nbsp;Factory&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;with&nbsp;our&nbsp;Factory&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supplier&nbsp;=&nbsp;factory;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;retry&nbsp;with&nbsp;current&nbsp;supplier&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supplier&nbsp;=&nbsp;valuesMap.get(subKey);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
我们可以看到它调用了 supplier.get(); 获取动态代理类，其中supplier是Factory,这个类定义在WeakCach的内部。</p>

<p>来瞅瞅，get里面又做了什么？</p>

<ol start="1">
	<li>public&nbsp;synchronized&nbsp;V&nbsp;get()&nbsp;{&nbsp;//&nbsp;serialize&nbsp;access&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;re-check&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supplier&lt;V&gt;&nbsp;supplier&nbsp;=&nbsp;valuesMap.get(subKey);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(supplier&nbsp;!=&nbsp;this)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;something&nbsp;changed&nbsp;while&nbsp;we&nbsp;were&nbsp;waiting:&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;might&nbsp;be&nbsp;that&nbsp;we&nbsp;were&nbsp;replaced&nbsp;by&nbsp;a&nbsp;CacheValue&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;or&nbsp;were&nbsp;removed&nbsp;because&nbsp;of&nbsp;failure&nbsp;-&gt;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return&nbsp;null&nbsp;to&nbsp;signal&nbsp;WeakCache.get()&nbsp;to&nbsp;retry&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;loop&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;else&nbsp;still&nbsp;us&nbsp;(supplier&nbsp;==&nbsp;this)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;new&nbsp;value&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;value&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;Objects.requireNonNull(valueFactory.apply(key,&nbsp;parameter));&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(value&nbsp;==&nbsp;null)&nbsp;{&nbsp;//&nbsp;remove&nbsp;us&nbsp;on&nbsp;failure&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuesMap.remove(subKey,&nbsp;this);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;only&nbsp;path&nbsp;to&nbsp;reach&nbsp;here&nbsp;is&nbsp;with&nbsp;non-null&nbsp;value&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;value&nbsp;!=&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;wrap&nbsp;value&nbsp;with&nbsp;CacheValue&nbsp;(WeakReference)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CacheValue&lt;V&gt;&nbsp;cacheValue&nbsp;=&nbsp;new&nbsp;CacheValue&lt;&gt;(value);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;try&nbsp;replacing&nbsp;us&nbsp;with&nbsp;CacheValue&nbsp;(this&nbsp;should&nbsp;always&nbsp;succeed)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(valuesMap.replace(subKey,&nbsp;this,&nbsp;cacheValue))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;put&nbsp;also&nbsp;in&nbsp;reverseMap&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverseMap.put(cacheValue,&nbsp;Boolean.TRUE);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;AssertionError(&quot;Should&nbsp;not&nbsp;reach&nbsp;here&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;successfully&nbsp;replaced&nbsp;us&nbsp;with&nbsp;new&nbsp;CacheValue&nbsp;-&gt;&nbsp;return&nbsp;the&nbsp;value&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;wrapped&nbsp;by&nbsp;it&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
发现重点还是木有出现，但我们可以看到它调用了valueFactory.apply(key, parameter)方法：</p>

<ol start="1">
	<li>/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;A&nbsp;factory&nbsp;function&nbsp;that&nbsp;generates,&nbsp;defines&nbsp;and&nbsp;returns&nbsp;the&nbsp;proxy&nbsp;class&nbsp;given&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;ClassLoader&nbsp;and&nbsp;array&nbsp;of&nbsp;interfaces.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;class&nbsp;ProxyClassFactory&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implements&nbsp;BiFunction&lt;ClassLoader,&nbsp;Class&lt;?&gt;[],&nbsp;Class&lt;?&gt;&gt;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;prefix&nbsp;for&nbsp;all&nbsp;proxy&nbsp;class&nbsp;names&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;String&nbsp;proxyClassNamePrefix&nbsp;=&nbsp;&quot;$Proxy&quot;;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;next&nbsp;number&nbsp;to&nbsp;use&nbsp;for&nbsp;generation&nbsp;of&nbsp;unique&nbsp;proxy&nbsp;class&nbsp;names&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;AtomicLong&nbsp;nextUniqueNumber&nbsp;=&nbsp;new&nbsp;AtomicLong();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Class&lt;?&gt;&nbsp;apply(ClassLoader&nbsp;loader,&nbsp;Class&lt;?&gt;[]&nbsp;interfaces)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;Class&lt;?&gt;,&nbsp;Boolean&gt;&nbsp;interfaceSet&nbsp;=&nbsp;new&nbsp;IdentityHashMap&lt;&gt;(interfaces.length);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Class&lt;?&gt;&nbsp;intf&nbsp;:&nbsp;interfaces)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Verify&nbsp;that&nbsp;the&nbsp;class&nbsp;loader&nbsp;resolves&nbsp;the&nbsp;name&nbsp;of&nbsp;this&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;interface&nbsp;to&nbsp;the&nbsp;same&nbsp;Class&nbsp;object.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt;&nbsp;interfaceClass&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interfaceClass&nbsp;=&nbsp;Class.forName(intf.getName(),&nbsp;false,&nbsp;loader);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(ClassNotFoundException&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(interfaceClass&nbsp;!=&nbsp;intf)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intf&nbsp;+&nbsp;&quot;&nbsp;is&nbsp;not&nbsp;visible&nbsp;from&nbsp;class&nbsp;loader&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Verify&nbsp;that&nbsp;the&nbsp;Class&nbsp;object&nbsp;actually&nbsp;represents&nbsp;an&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;interface.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!interfaceClass.isInterface())&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interfaceClass.getName()&nbsp;+&nbsp;&quot;&nbsp;is&nbsp;not&nbsp;an&nbsp;interface&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Verify&nbsp;that&nbsp;this&nbsp;interface&nbsp;is&nbsp;not&nbsp;a&nbsp;duplicate.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(interfaceSet.put(interfaceClass,&nbsp;Boolean.TRUE)&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;repeated&nbsp;interface:&nbsp;&quot;&nbsp;+&nbsp;interfaceClass.getName());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;proxyPkg&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;package&nbsp;to&nbsp;define&nbsp;proxy&nbsp;class&nbsp;in&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;accessFlags&nbsp;=&nbsp;Modifier.PUBLIC&nbsp;|&nbsp;Modifier.FINAL;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Record&nbsp;the&nbsp;package&nbsp;of&nbsp;a&nbsp;non-public&nbsp;proxy&nbsp;interface&nbsp;so&nbsp;that&nbsp;the&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;proxy&nbsp;class&nbsp;will&nbsp;be&nbsp;defined&nbsp;in&nbsp;the&nbsp;same&nbsp;package.&nbsp;&nbsp;Verify&nbsp;that&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;all&nbsp;non-public&nbsp;proxy&nbsp;interfaces&nbsp;are&nbsp;in&nbsp;the&nbsp;same&nbsp;package.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Class&lt;?&gt;&nbsp;intf&nbsp;:&nbsp;interfaces)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;flags&nbsp;=&nbsp;intf.getModifiers();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!Modifier.isPublic(flags))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accessFlags&nbsp;=&nbsp;Modifier.FINAL;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name&nbsp;=&nbsp;intf.getName();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;name.lastIndexOf(&#39;.&#39;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;pkg&nbsp;=&nbsp;((n&nbsp;==&nbsp;-1)&nbsp;?&nbsp;&quot;&quot;&nbsp;:&nbsp;name.substring(0,&nbsp;n&nbsp;+&nbsp;1));&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proxyPkg&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxyPkg&nbsp;=&nbsp;pkg;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(!pkg.equals(proxyPkg))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;non-public&nbsp;interfaces&nbsp;from&nbsp;different&nbsp;packages&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proxyPkg&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;if&nbsp;no&nbsp;non-public&nbsp;proxy&nbsp;interfaces,&nbsp;use&nbsp;com.sun.proxy&nbsp;package&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxyPkg&nbsp;=&nbsp;ReflectUtil.PROXY_PACKAGE&nbsp;+&nbsp;&quot;.&quot;;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Choose&nbsp;a&nbsp;name&nbsp;for&nbsp;the&nbsp;proxy&nbsp;class&nbsp;to&nbsp;generate.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;num&nbsp;=&nbsp;nextUniqueNumber.getAndIncrement();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;proxyName&nbsp;=&nbsp;proxyPkg&nbsp;+&nbsp;proxyClassNamePrefix&nbsp;+&nbsp;num;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Generate&nbsp;the&nbsp;specified&nbsp;proxy&nbsp;class.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;proxyClassFile&nbsp;=&nbsp;ProxyGenerator.generateProxyClass(&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxyName,&nbsp;interfaces,&nbsp;accessFlags);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;defineClass0(loader,&nbsp;proxyName,&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxyClassFile,&nbsp;0,&nbsp;proxyClassFile.length);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(ClassFormatError&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;A&nbsp;ClassFormatError&nbsp;here&nbsp;means&nbsp;that&nbsp;(barring&nbsp;bugs&nbsp;in&nbsp;the&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;proxy&nbsp;class&nbsp;generation&nbsp;code)&nbsp;there&nbsp;was&nbsp;some&nbsp;other&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;invalid&nbsp;aspect&nbsp;of&nbsp;the&nbsp;arguments&nbsp;supplied&nbsp;to&nbsp;the&nbsp;proxy&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;class&nbsp;creation&nbsp;(such&nbsp;as&nbsp;virtual&nbsp;machine&nbsp;limitations&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;exceeded).&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(e.toString());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p>通过看代码终于找到了重点：</p>

<ol start="1">
	<li>//生成字节码&nbsp;&nbsp;</li>
	<li>byte[]&nbsp;proxyClassFile&nbsp;=&nbsp;ProxyGenerator.generateProxyClass(proxyName,&nbsp;interfaces,&nbsp;accessFlags);&nbsp;&nbsp;</li>
</ol>

<p>那么接下来我们也使用测试一下，使用这个方法生成的字节码是个什么样子：</p>

<ol start="1">
	<li>package&nbsp;jiankunking;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>import&nbsp;sun.misc.ProxyGenerator;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>import&nbsp;java.io.File;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.io.FileNotFoundException;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.io.FileOutputStream;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.io.IOException;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.InvocationHandler;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.Proxy;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>/**&nbsp;</li>
	<li>&nbsp;*&nbsp;动态代理演示&nbsp;</li>
	<li>&nbsp;*/&nbsp;&nbsp;</li>
	<li>public&nbsp;class&nbsp;DynamicProxyDemonstration&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//代理的真实对象&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;realSubject&nbsp;=&nbsp;new&nbsp;RealSubject();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;InvocationHandlerImpl&nbsp;实现了&nbsp;InvocationHandler&nbsp;接口，并能实现方法调用从代理类到委托类的分派转发&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InvocationHandler&nbsp;handler&nbsp;=&nbsp;new&nbsp;InvocationHandlerImpl(realSubject);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassLoader&nbsp;loader&nbsp;=&nbsp;handler.getClass().getClassLoader();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class[]&nbsp;interfaces&nbsp;=&nbsp;realSubject.getClass().getInterfaces();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;subject&nbsp;=&nbsp;(Subject)&nbsp;Proxy.newProxyInstance(loader,&nbsp;interfaces,&nbsp;handler);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;动态代理对象的类型：&quot;+subject.getClass().getName());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;hello&nbsp;=&nbsp;subject.SayHello(&quot;jiankunking&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(hello);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将生成的字节码保存到本地，&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createProxyClassFile();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;void&nbsp;createProxyClassFile(){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name&nbsp;=&nbsp;&quot;ProxySubject&quot;;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;data&nbsp;=&nbsp;ProxyGenerator.generateProxyClass(name,new&nbsp;Class[]{Subject.class});&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileOutputStream&nbsp;out&nbsp;=null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out&nbsp;=&nbsp;new&nbsp;FileOutputStream(name+&quot;.class&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println((new&nbsp;File(&quot;hello&quot;)).getAbsolutePath());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.write(data);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(FileNotFoundException&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null!=out)&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.close();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>可以看一下这里代理对象的类型：</p>

<p><img alt="" src="http://img.blog.csdn.net/20161224233544058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmt1bmtpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></p>

<p>我们用jd-jui 工具将生成的字节码反编译：</p>

<ol start="1">
	<li>import&nbsp;java.lang.reflect.InvocationHandler;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.Method;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.Proxy;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.lang.reflect.UndeclaredThrowableException;&nbsp;&nbsp;</li>
	<li>import&nbsp;jiankunking.Subject;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>public&nbsp;final&nbsp;class&nbsp;ProxySubject&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;extends&nbsp;Proxy&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;implements&nbsp;Subject&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;private&nbsp;static&nbsp;Method&nbsp;m1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;private&nbsp;static&nbsp;Method&nbsp;m3;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;private&nbsp;static&nbsp;Method&nbsp;m4;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;private&nbsp;static&nbsp;Method&nbsp;m2;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;private&nbsp;static&nbsp;Method&nbsp;m0;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;public&nbsp;ProxySubject(InvocationHandler&nbsp;paramInvocationHandler)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;super(paramInvocationHandler);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;public&nbsp;final&nbsp;boolean&nbsp;equals(Object&nbsp;paramObject)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;((Boolean)this.h.invoke(this,&nbsp;m1,&nbsp;new&nbsp;Object[]&nbsp;{&nbsp;paramObject&nbsp;})).booleanValue();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Error|RuntimeException&nbsp;localError)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;localError;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;localThrowable)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UndeclaredThrowableException(localThrowable);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;public&nbsp;final&nbsp;String&nbsp;SayGoodBye()&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(String)this.h.invoke(this,&nbsp;m3,&nbsp;null);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Error|RuntimeException&nbsp;localError)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;localError;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;localThrowable)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UndeclaredThrowableException(localThrowable);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;public&nbsp;final&nbsp;String&nbsp;SayHello(String&nbsp;paramString)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(String)this.h.invoke(this,&nbsp;m4,&nbsp;new&nbsp;Object[]&nbsp;{&nbsp;paramString&nbsp;});&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Error|RuntimeException&nbsp;localError)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;localError;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;localThrowable)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UndeclaredThrowableException(localThrowable);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;public&nbsp;final&nbsp;String&nbsp;toString()&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(String)this.h.invoke(this,&nbsp;m2,&nbsp;null);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Error|RuntimeException&nbsp;localError)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;localError;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;localThrowable)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UndeclaredThrowableException(localThrowable);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;public&nbsp;final&nbsp;int&nbsp;hashCode()&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;((Integer)this.h.invoke(this,&nbsp;m0,&nbsp;null)).intValue();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Error|RuntimeException&nbsp;localError)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;localError;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;localThrowable)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UndeclaredThrowableException(localThrowable);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;static&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m1&nbsp;=&nbsp;Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;,&nbsp;new&nbsp;Class[]&nbsp;{&nbsp;Class.forName(&quot;java.lang.Object&quot;)&nbsp;});&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m3&nbsp;=&nbsp;Class.forName(&quot;jiankunking.Subject&quot;).getMethod(&quot;SayGoodBye&quot;,&nbsp;new&nbsp;Class[0]);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m4&nbsp;=&nbsp;Class.forName(&quot;jiankunking.Subject&quot;).getMethod(&quot;SayHello&quot;,&nbsp;new&nbsp;Class[]&nbsp;{&nbsp;Class.forName(&quot;java.lang.String&quot;)&nbsp;});&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m2&nbsp;=&nbsp;Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;,&nbsp;new&nbsp;Class[0]);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m0&nbsp;=&nbsp;Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;,&nbsp;new&nbsp;Class[0]);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(NoSuchMethodException&nbsp;localNoSuchMethodException)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NoSuchMethodError(localNoSuchMethodException.getMessage());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(ClassNotFoundException&nbsp;localClassNotFoundException)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NoClassDefFoundError(localClassNotFoundException.getMessage());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p><br />
这就是最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口<br />
也就是说：</p>

<p><strong>[java]</strong>&nbsp;<a href="http://blog.csdn.net/jiankunking/article/details/52143504#" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;" target="_blank" title="view plain">view plain</a>&nbsp;<a href="http://blog.csdn.net/jiankunking/article/details/52143504#" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;" target="_blank" title="copy">copy</a></p>

<p><embed allowscriptaccess="always" bgcolor="#ffffff" height="18" pluginspage="http://www.macromedia.com/go/getflashplayer" quality="best" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" type="application/x-shockwave-flash" width="18" wmode="transparent"></embed></p>

<ol start="1">
	<li>Subject&nbsp;subject&nbsp;=&nbsp;(Subject)&nbsp;Proxy.newProxyInstance(loader,&nbsp;interfaces,&nbsp;handler);&nbsp;&nbsp;</li>
</ol>

<p>这里的subject实际是这个类的一个实例，那么我们调用它的：</p>

<ol start="1">
	<li>public&nbsp;final&nbsp;String&nbsp;SayHello(String&nbsp;paramString)&nbsp;&nbsp;</li>
</ol>

<p>就是调用我们定义的InvocationHandlerImpl的 invoke方法：</p>

<p><img alt="" src="http://img.blog.csdn.net/20160807195202428?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p>======================横线之间的是代码跟分析的过程，不想看的朋友可以直接看结论=====================================</p>

<h2>五、结论</h2>

<pre>
到了这里，终于解答了：</pre>

<pre>
subject.SayHello(<strong>&quot;jiankunking&quot;</strong>)这句话时，为什么会自动调用InvocationHandlerImpl的invoke方法？
</pre>

<pre>

&nbsp;</pre>

<pre>
<strong>因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，在实现Subject接口方法的内部，通过反射调用了</strong></pre>

<pre>
<strong>InvocationHandlerImpl的invoke方法。</strong></pre>

<pre>
<strong>
</strong></pre>

<pre>
包含生成本地class文件的demo：</pre>

<pre>
<a href="http://download.csdn.net/detail/xunzaosiyecao/9597474" target="_blank">http://download.csdn.net/detail/xunzaosiyecao/9597474</a></pre>

<pre>
<a href="https://github.com/JianKunKing/DynamicProxyDemo" target="_blank">https://github.com/JianKunKing/DynamicProxyDemo</a>
</pre>

<pre>

&nbsp;</pre>

<pre>
通过分析代码可以看出Java 动态代理，具体有如下四步骤：
</pre>

<ol>
	<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
	<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
	<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
	<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ol>
