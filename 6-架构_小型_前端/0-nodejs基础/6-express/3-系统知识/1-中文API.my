<h1>Express 4.x API 中文文档</h1>

<h2>express()</h2>

<p><strong>express()</strong>用来创建一个Express的程序。<strong>express()</strong>方法是<strong><em>express</em></strong>模块导出的顶层方法。</p>

<pre>
var express = require(&#39;express&#39;);
var app = express();</pre>

<h3>Methods</h3>

<h4>express.static(root, [options])</h4>

<p><strong>express.static</strong>是Express中唯一的内建中间件。它以<a href="https://github.com/expressjs/serve-static" target="_blank">server-static</a>模块为基础开发，负责托管 Express 应用内的静态资源。 参数<strong>root</strong>为静态资源的所在的根目录。 参数<strong>options</strong>是可选的，支持以下的属性：</p>

<table>
	<thead>
		<tr>
			<th>属性</th>
			<th>描述</th>
			<th>类型</th>
			<th>默认值</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>dotfiles</td>
			<td>是否响应点文件。供选择的值有&quot;allow&quot;，&quot;deny&quot;和&quot;ignore&quot;</td>
			<td>String</td>
			<td>&quot;ignore&quot;</td>
		</tr>
		<tr>
			<td>etag</td>
			<td>使能或者关闭etag</td>
			<td>Boolean</td>
			<td>true</td>
		</tr>
		<tr>
			<td>extensions</td>
			<td>设置文件延期回退</td>
			<td>Boolean</td>
			<td>true</td>
		</tr>
		<tr>
			<td>index</td>
			<td>发送目录索引文件。设置false将不发送。</td>
			<td>Mixed</td>
			<td>&quot;index.html&quot;</td>
		</tr>
		<tr>
			<td>lastModified</td>
			<td>设置文件在系统中的最后修改时间到<strong>Last-Modified</strong>头部。可能的取值有<strong>false</strong>和<strong>true</strong>。</td>
			<td>Boolean</td>
			<td>true</td>
		</tr>
		<tr>
			<td>maxAge</td>
			<td>在Cache-Control头部中设置<strong>max-age</strong>属性，精度为毫秒(ms)或则一段<a href="https://www.npmjs.org/package/ms" target="_blank">ms format</a>的字符串</td>
			<td>Number</td>
			<td>0</td>
		</tr>
		<tr>
			<td>redirect</td>
			<td>当请求的pathname是一个目录的时候，重定向到尾随&quot;/&quot;</td>
			<td>Boolean</td>
			<td>true</td>
		</tr>
		<tr>
			<td>setHeaders</td>
			<td>当响应静态文件请求时设置headers的方法</td>
			<td>Funtion</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>

<p>如果你想获得更多关于使用中间件的细节，你可以查阅<a href="http://expressjs.com/starter/static-files.html" target="_blank">Serving static files in Express</a>。</p>

<h2>Application()</h2>

<p><strong>app</strong>对象一般用来表示Express程序。通过调用Express模块导出的顶层的<strong>express()</strong>方法来创建它:</p>

<pre>
var express = require(&#39;express&#39;);
var app = express();

app.get(&#39;/&#39;, function(req, res) {
    res.send(&#39;hello world!&#39;);
});

app.listen(3000);</pre>

<p>app 对象具有以下的方法：</p>

<ul>
	<li>路由HTTP请求；具体可以看<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_19">app.METHOD</a>和<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_20">app.param</a>这两个例子。</li>
	<li>配置中间件；具体请看<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_24">app.route</a>。</li>
	<li>渲染HTML视图；具体请看<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_23">app.render</a>。</li>
	<li>注册模板引擎；具体请看<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_15">app.engine</a>。</li>
</ul>

<p>它还有一些属性设置，这些属性可以改变程序的行为。获得更多的信息，可以查阅<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table">Application settings</a>。</p>

<h3>Properties</h3>

<h4>app.locals</h4>

<p>app.locals对象是一个javascript对象，它的属性就是程序本地的变量。</p>

<pre>
app.locals.title
// =&gt; &#39;My App&#39;
app.locals.email
// =&gt; &#39;me@myapp.com&#39;</pre>

<p>一旦设定，<strong>app.locals</strong>的各属性值将贯穿程序的整个生命周期，与其相反的是&nbsp;<strong>res.locals</strong>&nbsp;，它只在这次请求的生命周期中有效。</p>

<p>在程序中，你可以在渲染模板时使用这些本地变量。它们是非常有用的，可以为模板提供一些有用的方法，以及<strong>app</strong>级别的数据。通过<strong>req.app.locals</strong>(具体查看<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_28">req.app</a>)，Locals可以在中间件中使用。</p>

<pre>
app.locals.title = &#39;My App&#39;;
app.locals.strftime = require(&#39;strftime&#39;);
app.locals.email = &#39;me@myapp.com&#39;;</pre>

<h4>app.mountpath</h4>

<p><strong>app.mountpath</strong>属性是子程序挂载的路径模式。</p>

<blockquote>
<p>一个子程序是一个<strong>express</strong>的实例，其可以被用来作为路由句柄来处理请求。</p>
</blockquote>

<pre>
var express = require(&#39;express&#39;);
var app = express(); // the main app
var admin = express(); // the sub app
admin.get(&#39;/&#39;, function(req, res) {
    console.log(admin.mountpath); // /admin
    res.send(&#39;Admin Homepage&#39;);
});
app.use(&#39;/admin&#39;, admin); // mount the sub app</pre>

<p>它和req对象的<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_29">req.baseUrl</a>&nbsp;)属性比较相似，除了req.baseUrl是匹配的URL路径，而不是匹配的模式。如果一个子程序被挂载在多条路径模式，app.mountpath就是一个关于挂载路径模式项的列表，如下面例子所示。</p>

<pre>
var admin = express();

admin.get(&#39;/&#39;, function (req, res) {
  console.log(admin.mountpath); // [ &#39;/adm*n&#39;, &#39;/manager&#39; ]
  res.send(&#39;Admin Homepage&#39;);
});

var secret = express();
secret.get(&#39;/&#39;, function (req, res) {
  console.log(secret.mountpath); // /secr*t
  res.send(&#39;Admin Secret&#39;);
});

admin.use(&#39;/secr*t&#39;, secret); // load the &#39;secret&#39; router on &#39;/secr*t&#39;, on the &#39;admin&#39; sub app
app.use([&#39;/adm*n&#39;, &#39;/manager&#39;], admin); // load the &#39;admin&#39; router on &#39;/adm*n&#39; and &#39;/manager&#39;, on the parent app</pre>

<h2>Events</h2>

<h3>app.on(&#39;mount&#39;, callback(parent))</h3>

<p>当子程序被挂载到父程序时，mount事件被发射。父程序对象作为参数，传递给回调方法。</p>

<pre>
var admin = express();
admin.on(&#39;mount&#39;, function(parent) {
    console.log(&#39;Admin Mounted&#39;);
    console.log(parent); // refers to the parent app
});
admin.get(&#39;/&#39;, function(req, res) {
    res.send(&#39;Admin Homepage&#39;);
});
app.use(&#39;/admin&#39;, admin);</pre>

<h3>Methods</h3>

<h4>app.all(path, callback[, callback ...]</h4>

<p><strong>app.all</strong>方法和标准的<strong>app.METHOD()</strong>方法相似，除了它匹配所有的HTTP动词。 对于给一个特殊前缀映射一个全局的逻辑处理，或者无条件匹配，它是很有效的。例如，如果你把下面内容放在所有其他的路由定义的前面，它要求所有从这个点开始的路由需要认证和自动加载一个用户。记住这些回调并不是一定是终点:<strong>loadUser</strong>可以在完成了一个任务后，调用<strong>next()</strong>方法来继续匹配随后的路由。</p>

<pre>
app.all(&#39;*&#39;, requireAuthentication, loadUser);</pre>

<p>或者这种相等的形式:</p>

<pre>
app.all(&#39;*&#39;, requireAuthentication);
app.all(&#39;*&#39;, loadUser);</pre>

<p>另一个例子是全局的白名单方法。这个例子和前面的很像，然而它只是限制以<strong>/api</strong>开头的路径。</p>

<pre>
app.all(&#39;/api/*&#39;, requireAuthentication);</pre>

<h4>app.delete(path, callback[, callback ...])</h4>

<p>路由<strong>HTTP DELETE</strong>请求到有特殊回调方法的特殊的路径。获取更多的信息，可以查阅<a href="http://expressjs.com/guide/routing.html" target="_blank">routing guide</a>。 你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用<strong>next(&#39;router&#39;)</strong>来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果不能满足当前路由的处理条件，那么你可以传递控制到随后的路由。</p>

<pre>
app.delete(&#39;/&#39;, function(req, res) {
    res.send(&#39;DELETE request to homepage&#39;);
});</pre>

<h4>app.disable(name)</h4>

<p>设置类型为布尔的设置名为<strong>name</strong>的值为<strong>false</strong>，此处的<strong>name</strong>是<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table">app settings table</a>中各属性的一个。调用<strong>app.set(&#39;foo&#39;, false)</strong>和调用<strong>app.disable(&#39;foo&#39;)</strong>是等价的。 比如:</p>

<pre>
app.disable(&#39;trust proxy&#39;);
app.get(&#39;trust proxy&#39;);
// =&gt; false</pre>

<h4>app.disabled(name)</h4>

<p>返回<strong>true</strong>如果布尔类型的设置值<strong>name</strong>被禁用为<strong>false</strong>，此处的<strong>name</strong>是<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table" target="_blank">app settings table</a>中各属性的一个。</p>

<pre>
app.disabled(&#39;trust proxy&#39;);
// =&gt; true
app.enable(&#39;trust proxy&#39;);
app.disabled(&#39;trust proxy&#39;);
// =&gt; false</pre>

<h4>app.enable(name)</h4>

<p>设置布尔类型的设置值<strong>name</strong>为<strong>true</strong>，此处的<strong>name</strong>是app settings table中各属性的一个。调用<strong>app.set(&#39;foo&#39;, true)</strong>和调用<strong>app.enable(&#39;foo&#39;)</strong>是等价的。</p>

<pre>
app.enable(&#39;trust proxy&#39;);
app.get(&#39;trust proxy&#39;);
// =&gt; true</pre>

<h4>app.enabled(name)</h4>

<p>返回<strong>true</strong>如果布尔类型的设置值<strong>name</strong>被启动为<strong>true</strong>，此处的<strong>name</strong>是<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table" target="_blank">app settings table</a>中各属性的一个。</p>

<pre>
app.enabled(&#39;trust proxy&#39;);
// =&gt; false
app.enable(&#39;trust proxy&#39;);
app.enabled(&#39;trust proxy&#39;);
// =&gt; true</pre>

<h4>app.engine(ext, callback)</h4>

<p>注册给定引擎的回调，用来渲染处理ext文件。 默认情况下，Express需要使用<strong>require()</strong>来加载基于文件扩展的引擎。例如，如果你尝试渲染一个<strong>foo.jade</strong>文件，Express在内部调用下面的内容，同时缓存<strong>require()</strong>结果供随后的调用，来加速性能。</p>

<pre>
app.engine(&#39;jade&#39;, require(&#39;jade&#39;).__express);</pre>

<p>使用下面的方法对于那些没有提供开箱即用的<strong>.__express</strong>方法的模板，或者你希望使用不同的模板引擎扩展。 比如，使用EJS模板引擎来渲染<strong>.html</strong>文件：</p>

<pre>
app.engine(&#39;html&#39;, require(&#39;ejs&#39;).renderFile);</pre>

<p>在这个例子中，EJS提供了一个<strong>.renderFile</strong>方法，这个方法满足了Express规定的签名规则：<strong>(path, options, callback)</strong>，然而记住在内部它只是<strong>ejs.__express</strong>的一个别名，所以你可以在不做任何事的情况下直接使用<strong>.ejs</strong>扩展。 一些模板引擎没有遵循这种规范，<a href="https://github.com/tj/consolidate.js" target="_blank">consolidate.js</a>库映射模板引擎以下面的使用方式，所以他们可以无缝的和Express工作。</p>

<pre>
var engines = require(&#39;consolidate&#39;);
app.engine(&#39;haml&#39;, engines.haml);
app.engine(&#39;html&#39;, engines.hogan);</pre>

<h4>app.get(name)</h4>

<p>获得设置名为<strong>name</strong>的app设置的值，此处的<strong>name</strong>是<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table" target="_blank">app settings table</a>中各属性的一个。 如下：</p>

<pre>
app.get(&#39;title&#39;);
// =&gt; undefined
app.set(&#39;title&#39;, &#39;My Site&#39;);
app.get(&#39;title&#39;);
// =&gt; &#39;My Site&#39;</pre>

<h4>app.get(path, callback [, callback ...])</h4>

<p>路由<strong>HTTP GET</strong>请求到有特殊回调的特殊路径。获取更多的信息，可以查阅<a href="http://expressjs.com/guide/routing.html" target="_blank">routing guide</a>。 你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用<strong>next(&#39;router&#39;)</strong>来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由。</p>

<pre>
app.get(&#39;/&#39;, function(req, res) {
    res.send(&#39;GET request to homepage&#39;);
});</pre>

<h4>app.listen(port, [hostname], [backlog], [callback])</h4>

<p>绑定程序监听端口到指定的主机和端口号。这个方法和<strong>Node</strong>中的<a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback" target="_blank">http.Server.listen()</a>是一样的。</p>

<pre>
var express = require(&#39;express&#39;);
var app = express();
app.listen(3000);</pre>

<p>通过调用<strong>express()</strong>返回得到的<strong>app</strong>实际上是一个JavaScript的<strong>Function</strong>，被设计用来作为一个回调传递给<strong>Node HTTP servers</strong>来处理请求。这样，其就可以很简便的基于同一份代码提供http和https版本，所以app没有从这些继承(它只是一个简单的回调)。</p>

<pre>
var express = require(&#39;express&#39;);
var https = require(&#39;https&#39;);
var http = require(&#39;http&#39;);
http.createServer(app).listen(80);
https.createServer(options, app).listen(443);</pre>

<p>app.listen()方法是下面所示的一个便利的方法(只针对HTTP协议):</p>

<pre>
app.listen = function() {
    var server = http.createServer(this);
    return server.listen.apply(server, arguments);
};</pre>

<h4>app.METHOD(path, callback [, callback ...])</h4>

<p>路由一个HTTP请求，<strong>METHOD</strong>是这个请求的HTTP方法，比如<strong>GET</strong>，<strong>PUT</strong>，<strong>POST</strong>等等，注意是小写的。所以，实际的方法是<strong>app.get()</strong>，<strong>app.post()</strong>，<strong>app.put()</strong>等等。下面有关于方法的完整的表。</p>

<p>获取更多信息，请看<a href="http://expressjs.com/guide/routing.html" target="_blank">routing guide</a>。 Express支持下面的路由方法，对应与同名的HTTP方法：</p>

<table>
	<tbody>
		<tr>
			<td>
			<ul>
				<li>checkout</li>
				<li>connect</li>
				<li>copy</li>
				<li>delete</li>
				<li>get</li>
				<li>head</li>
				<li>lock</li>
				<li>merge</li>
				<li>mkactivity
				<ul>
				</ul>
				</li>
			</ul>
			</td>
			<td>
			<ul>
				<li>mkcol</li>
				<li>move</li>
				<li>m-search</li>
				<li>notify</li>
				<li>options</li>
				<li>patch</li>
				<li>post</li>
				<li>propfind</li>
				<li>proppatch
				<ul>
				</ul>
				</li>
			</ul>
			</td>
			<td>
			<ul>
				<li>purege</li>
				<li>put</li>
				<li>report</li>
				<li>search</li>
				<li>subscribe</li>
				<li>trace</li>
				<li>unlock</li>
				<li>unsubscribe
				<ul>
				</ul>
				</li>
			</ul>
			</td>
		</tr>
		<tr>
		</tr>
	</tbody>
</table>

<blockquote>
<p>如果使用上述方法时，导致了无效的javascript的变量名，可以使用中括号符号，比如,<strong>app[&#39;m-search&#39;](&#39;/&#39;, function ...</strong></p>
</blockquote>

<p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用<strong>next(&#39;router&#39;)</strong>来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没有满足当前路由的处理条件，那么传递控制到随后的路由。</p>

<blockquote>
<p>本API文档把使用比较多的HTTP方法<strong>app.get()</strong>，<strong>app.post</strong>，<strong>app.put()</strong>，<strong>app.delete()</strong>作为一个个单独的项进行说明。然而，其他上述列出的方法以完全相同的方式工作。</p>
</blockquote>

<p><strong>app.all()</strong>是一个特殊的路由方法，它不属于HTTP协议中的规定的方法。它为一个路径加载中间件，其对所有的请求方法都有效。</p>

<pre>
app.all(&#39;/secret&#39;, function (req, res) {
    console.log(&#39;Accessing the secret section...&#39;);
    next(); // pass control to the next handler
});</pre>

<h4>app.param([name], callback)</h4>

<p>给路由参数添加回调触发器，这里的<strong>name</strong>是参数名或者参数数组，<strong>function</strong>是回调方法。回调方法的参数按序是<strong>请求对象</strong>，<strong>响应对象</strong>，<strong>下个中间件</strong>，<strong>参数值</strong>和<strong>参数名</strong>。 如果<strong>name</strong>是数组，会按照各个参数在数组中被声明的顺序将回调触发器注册下来。还有，对于除了最后一个参数的其他参数，在他们的回调中调用<strong>next()</strong>来调用下个声明参数的回调。对于最后一个参数，在回调中调用<strong>next()</strong>将调用位于当前处理路由中的下一个中间件，如果<strong>name</strong>只是一个<strong>string</strong>那就和它是一样的(就是说只有一个参数，那么就是最后一个参数，和数组中最后一个参数是一样的)。 例如，当<strong>:user</strong>出现在路由路径中，你可以映射用户加载的逻辑处理来自动提供<strong>req.user</strong>给这个路由，或者对输入的参数进行验证。</p>

<pre>
app.param(&#39;user&#39;, function(req, res, next, id) {
    User.find(id, function(error, user) {
        if (err) {
            next(err);
        }
        else if (user){
            req.user = user;
        } else {
            next(new Error(&#39;failed to load user&#39;));
        }
    });
});</pre>

<p>对于<strong>Param</strong>的回调定义的路由来说，他们是局部的。它们不会被挂载的app或者路由继承。所以，定义在<strong>app</strong>上的<strong>Param</strong>回调只有是在<strong>app</strong>上的路由具有这个路由参数时才起作用。</p>

<p>在定义<strong>param</strong>的路由上，<strong>param</strong>回调都是第一个被调用的，它们在一个请求-响应循环中都会被调用一次并且只有一次，即使多个路由都匹配，如下面的例子：</p>

<pre>
app.param(&#39;id&#39;, function(req, res, next, id) {
    console.log(&#39;CALLED ONLY ONCE&#39;);
    next();
});
app.get(&#39;/user/:id&#39;, function(req, res, next) {
    console.log(&#39;although this matches&#39;);
    next();
});
app.get(&#39;/user/:id&#39;, function(req, res) {
    console.log(&#39;and this mathces too&#39;);
    res.end();
});</pre>

<p>当GET /user/42，得到下面的结果:</p>

<pre>
CALLED ONLY ONCE
although this matches
and this matches too</pre>

<pre>
app.param([&#39;id&#39;, &#39;page&#39;], function(req, res, next, value) {
    console.log(&#39;CALLED ONLY ONCE with&#39;, value);
    next();
});
app.get(&#39;/user/:id/:page&#39;, function(req. res, next) {
    console.log(&#39;although this matches&#39;);
    next();
});
app.get(&#39;/user/:id/:page&#39;, function (req, res, next) {
    console.log(&#39;and this matches too&#39;);
    res.end();
});</pre>

<p>当执行GET /user/42/3，结果如下：</p>

<pre>
CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this mathes too</pre>

<blockquote>
<p>下面章节描述的<strong>app.param(callback)</strong>在v4.11.0之后被弃用。</p>
</blockquote>

<p>通过只传递一个回调参数给<strong>app.param(name, callback)</strong>方法，<strong>app.param(naem, callback)</strong>方法的行为将被完全改变。这个回调参数是关于<strong>app.param(name, callback)</strong>该具有怎样的行为的一个自定义方法，这个方法必须接受两个参数并且返回一个中间件。 这个回调的第一个参数就是需要捕获的url的参数名，第二个参数可以是任一的JavaScript对象，其可能在实现返回一个中间件时被使用。 这个回调方法返回的中间件决定了当URL中包含这个参数时所采取的行为。 在下面的例子中，<strong>app.param(name, callback)</strong>参数签名被修改成了<strong>app.param(name, accessId)</strong>。替换接受一个参数名和回调，<strong>app.param()</strong>现在接受一个参数名和一个数字。</p>

<pre>
var express = require(&#39;express&#39;);
var app = express();
app.param(function(param, option){
    return function(req, res, next, val) {
        if (val == option) {
            next();
        }
        else {
            res.sendStatus(403);
        }
    }
});
app.param(&#39;id&#39;, 1337);
app.get(&#39;/user/:id&#39;, function(req, res) {
    res.send(&#39;Ok&#39;);
});
app.listen(3000, function() {
    console.log(&#39;Ready&#39;);
}); </pre>

<p>在这个例子中，app.param(name, callback)参数签名保持和原来一样，但是替换成了一个中间件，定义了一个自定义的数据类型检测方法来检测user id的类型正确性。</p>

<pre>
app.param(function(param, validator) {
    return function(req, res, next, val) {
        if (validator(val)) {
            next();
        }
        else {
            res.sendStatus(403);
        }
    }
});
app.param(&#39;id&#39;, function(candidate) {
    return !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);
});</pre>

<blockquote>
<p>在使用正则表达式来，不要使用<strong>.</strong>。例如，你不能使用<strong>/user-.+/</strong>来捕获<strong>user-gami</strong>，用使用<strong>[\\s\\S]</strong>或者<strong>[\\w\\&gt;W]</strong>来代替(正如<strong>/user-[\\s\\S]+/</strong>)。</p>

<pre>
//captures &#39;1-a_6&#39; but not &#39;543-azser-sder&#39;
router.get(&#39;/[0-9]+-[[\\w]]*&#39;, function); 
//captures &#39;1-a_6&#39; and &#39;543-az(ser&quot;-sder&#39; but not &#39;5-a s&#39;
router.get(&#39;/[0-9]+-[[\\S]]*&#39;, function); 
//captures all (equivalent to &#39;.*&#39;)
router.get(&#39;[[\\s\\S]]*&#39;, function); </pre>
</blockquote>

<h4>app.path()</h4>

<p>通过这个方法可以得到<strong>app</strong>典型的路径，其是一个<strong>string</strong>。</p>

<pre>
 var app = express()
      , blog = express()
      , blogAdmin = express();
    app.use(&#39;/blog&#39;, blog);
    app.use(&#39;/admin&#39;, blogAdmin);
    console.log(app.path()); // &#39;&#39;
    console.log(blog.path()); // &#39;/blog&#39;
    console.log(blogAdmin.path()); // &#39;/blog/admin&#39;</pre>

<p>如果app挂载很复杂下，那么这个方法的行为也会很复杂：一种更好用的方式是使用req.baseUrl来获得这个app的典型路径。</p>

<h4>app.post(path, callback, [callback ...])</h4>

<p>路由HTTP POST请求到有特殊回调的特殊路径。获取更多的信息，可以查阅[routing guide](http://expressjs.com/guide/routing.html)。</p>

<p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用next(&#39;router&#39;)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由。</p>

<pre>
app.post(&#39;/&#39;, function(req, res) {
    res.send(&#39;POST request to homepage&#39;)
});</pre>

<h4>app.put(path, callback, [callback ...])</h4>

<p>路由<strong>HTTP PUT</strong>请求到有特殊回调的特殊路径。获取更多的信息，可以查阅<a href="http://expressjs.com/guide/routing.html" target="_blank">routing guide</a>。</p>

<p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用<strong>next(&#39;router&#39;)</strong>来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由。</p>

<pre>
app.put(&#39;/&#39;, function(req, res) {
    res.send(&#39;PUT request to homepage&#39;);
});</pre>

<h4>app.render(view, [locals], callback)</h4>

<p>通过<strong>callback</strong>回调返回一个<strong>view</strong>渲染之后得到的HTML文本。它可以接受一个可选的参数，可选参数包含了这个<strong>view</strong>需要用到的本地数据。这个方法类似于<strong>res.render()</strong>，<strong>除了它不能把渲染得到的HTML文本发送给客户端</strong>。</p>

<blockquote>
<p>将<strong>app.render()</strong>当作是可以生成渲染视图字符串的工具方法。在<strong>res.render()</strong>内部，就是使用的<strong>app.render()</strong>来渲染视图。</p>

<p>如果使能了视图缓存，那么本地变量缓存就会保留。如果你想在开发的过程中缓存视图，设置它为<strong>true</strong>。在生产环境中，视图缓存默认是打开的。</p>
</blockquote>

<pre>
app.render(&#39;email&#39;, function(err, html) {
// ...
});
app.render(&#39;email&#39;, {name:&#39;Tobi&#39;}, function(err, html) {
// ...
});</pre>

<h4>app.route(path)</h4>

<p>返回一个单例模式的路由的实例，之后你可以在其上施加各种HTTP动作的中间件。使用<strong>app.route()</strong>来避免重复路由名字(例如错字错误)--说的意思应该是使用<strong>app.router()</strong>这个单例方法来避免同一个路径多个路由实例。</p>

<pre>
var app = express();
app.route(&#39;/events&#39;)
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(...);
})
.post(function(req, res, next) {
  // maybe add a new event...
})</pre>

<h4>app.set(name, value)</h4>

<p>给 name 设置项赋 value 值，name 是&nbsp;<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table" target="_blank">Application settings</a>&nbsp;中属性的一项。 对于一个类型是布尔型的属性调用app.set(&#39;foo&#39;, ture)等价于调用app.enable(&#39;foo&#39;)。同样的，调用app.set(&#39;foo&#39;, false)等价于调用app.disable(&#39;foo&#39;)。</p>

<p>可以使用app.get()来取得设置的值：</p>

<pre>
app.set(&#39;title&#39;, &#39;My Site&#39;);
    app.get(&#39;title&#39;); // &#39;My Site&#39;</pre>

<p><strong>Application Settings</strong></p>

<p>如果<strong>name</strong>是程序设置之一，它将影响到程序的行为。下边列出了程序中的设置。</p>

<table>
	<thead>
		<tr>
			<th>属性</th>
			<th>类型</th>
			<th>值</th>
			<th>默认</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>case sensitive routing</td>
			<td>Boolean</td>
			<td>启用区分大小写。</td>
			<td>不启用。对<strong>/Foo</strong>和<strong>/foo</strong>处理是一样。</td>
		</tr>
		<tr>
			<td>env</td>
			<td>String</td>
			<td>环境模型。</td>
			<td>process.env.NODE<em>ENV(NODE</em>ENV环境变量)或者&quot;development&quot;</td>
		</tr>
		<tr>
			<td>etag</td>
			<td>Varied</td>
			<td>设置<strong>ETag</strong>响应头。可取的值，可以查阅<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#etag.options.table">etag options table</a>。更多关于<a href="http://en.wikipedia.org/wiki/HTTP_ETag" target="_blank">HTTP ETag header</a>。</td>
			<td>weak</td>
		</tr>
		<tr>
			<td>jsonp callback name</td>
			<td>String</td>
			<td>指定默认JSONP回调的名称。</td>
			<td>?callback=</td>
		</tr>
		<tr>
			<td>json replacer</td>
			<td>String</td>
			<td>JSON替代品回调</td>
			<td>null</td>
		</tr>
		<tr>
			<td>json spaces</td>
			<td>Number</td>
			<td>当设置了这个值后，发送缩进空格美化过的JSON字符串。</td>
			<td>Disabled</td>
		</tr>
		<tr>
			<td>query parser</td>
			<td>Varied</td>
			<td>设置值为<strong>false</strong>来禁用<strong>query parser</strong>，或者设置<strong>simple</strong>,<strong>extended</strong>，也可以自己实现<strong>query string</strong>解析函数。<strong>simple</strong>基于<strong>Node</strong>原生的<strong>query</strong>解析，<a href="http://nodejs.org/api/querystring.html" target="_blank">querystring</a>。</td>
			<td>&quot;extend&quot;</td>
		</tr>
		<tr>
			<td>strict routing</td>
			<td>Boolean</td>
			<td>启用严格的路由。</td>
			<td>不启用。对<strong>/foo</strong>和<strong>/foo/</strong>的路由处理是一样。</td>
		</tr>
		<tr>
			<td>subdomain offset</td>
			<td>Number</td>
			<td>用来删除访问子域的主机点分部分的个数</td>
			<td>2</td>
		</tr>
		<tr>
			<td>trust proxy</td>
			<td>Varied</td>
			<td>指示<strong>app</strong>在一个反向代理的后面，使用<strong>x-Forwarded-*</strong>来确定连接和客户端的IP地址。注意:<strong>X-Forwarded-*</strong>头部很容易被欺骗，所有检测客户端的IP地址是靠不住的。<strong>trust proxy</strong>默认不启用。当启用时，Express尝试通过前端代理或者一系列代理来获取已连接的客户端IP地址。<strong>req.ips</strong>属性包含了已连接客户端IP地址的一个数组。为了启动它，需要设置在下面<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#trust.proxy.options.table">trust proxy options table</a>中定义的值。<strong>trust proxy</strong>的设置实现使用了<strong>proxy-addr</strong>包。如果想获得更多的信息，可以查阅它的文档</td>
			<td>Disable</td>
		</tr>
		<tr>
			<td>views</td>
			<td>String or Array</td>
			<td><strong>view</strong>所在的目录或者目录数组。如果是一个数组，将按在数组中的顺序来查找<strong>view</strong>。</td>
			<td>process.cwd() + &#39;/views&#39;</td>
		</tr>
		<tr>
			<td>view cache</td>
			<td>Boolean</td>
			<td>启用视图模板编译缓存。</td>
			<td>在生成环境默认开启。</td>
		</tr>
		<tr>
			<td>view engine</td>
			<td>String</td>
			<td>省略时，默认的引擎被扩展使用。</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>x-powered-by</td>
			<td>Boolean</td>
			<td>启用<strong>X-Powered-By:Express</strong>HTTP头部</td>
			<td>true</td>
		</tr>
	</tbody>
</table>

<p><strong><strong>trust proxy</strong>&nbsp;选项设置</strong>&nbsp;查阅<a href="http://expressjs.com/guide/behind-proxies.html" target="_blank">Express behind proxies</a>来获取更多信息。</p>

<table>
	<thead>
		<tr>
			<th>Type</th>
			<th>Value</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Boolean</td>
			<td>
			<p>如果为<strong>true</strong>，客户端的IP地址作为<strong>X-Forwarded-*</strong>头部的最左边的条目。如果为<strong>false</strong>，可以理解为<strong>app</strong>直接与英特网直连，客户端的IP地址衍生自<strong>req.connection.remoteAddress</strong>。<strong>false</strong>是默认设置。</p>
			</td>
		</tr>
		<tr>
			<td>IP addresses</td>
			<td>
			<p>一个IP地址，子网，或者一组IP地址，和委托子网。下面列出的是一个预先配置的子网名列表。</p>

			<ul>
				<li>loopback -&nbsp;<strong>127.0.0.1/8</strong>,&nbsp;<strong>::1/128</strong></li>
				<li>linklocal -&nbsp;<strong>169.254.0.0/16</strong>,&nbsp;<strong>fe80::/10</strong></li>
				<li>uniquelocal -&nbsp;<strong>10.0.0.0/8</strong>,&nbsp;<strong>172.16.0.0/12</strong>,&nbsp;<strong>192.168.0.0/16</strong>,&nbsp;<strong>fc00::/7</strong></li>
			</ul>

			<p>使用下面方法中的任何一种来设置IP地址:</p>

			<pre>
app.set(&#39;trust proxy&#39;, &#39;loopback&#39;) // specify a single subnet
app.set(&#39;trust proxy&#39;, &#39;loopback, 123.123.123.123&#39;) // specify a subnet and an address
app.set(&#39;trust proxy&#39;, &#39;loopback, linklocal, uniquelocal&#39;) // specify multiple subnets as CSV
app.set(&#39;trust proxy&#39;, [&#39;loopback&#39;, &#39;linklocal&#39;, &#39;uniquelocal&#39;]) // specify multiple subnets as an array</pre>

			<p>当指定IP地址之后, 这个IP地址或子网会被设置了这个IP地址或子网的app排除在外, 最靠近程序服务的没有委托的地址将被看做客户端IP地址。</p>
			</td>
		</tr>
		<tr>
			<td>Number</td>
			<td>
			<p>信任从反向代理到app中间小于等于n跳的连接为客户端。</p>
			</td>
		</tr>
		<tr>
			<td>Function</td>
			<td>
			<p>客户自定义委托代理信任机制。如果你使用这个，请确保你自己知道你在干什么。</p>

			<pre>
app.set(&#39;trust proxy&#39;, function (ip) {
    if (ip === &#39;127.0.0.1&#39; || ip === &#39;123.123.123.123&#39;) return true; // trusted IPs
    else return false;
  })</pre>
			</td>
		</tr>
	</tbody>
</table>

<p><strong><strong>etag</strong>&nbsp;设置选项</strong>&nbsp;<strong>ETag</strong>功能的实现使用了<a href="https://www.npmjs.org/package/etag" target="_blank">etag</a>包。如果你需要获得更多的信息，你可以查阅它的文档。</p>

<table>
	<thead>
		<tr>
			<th>Type</th>
			<th>Value</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Boolean</td>
			<td>
			<p>设置为<strong>true</strong>，启用weak ETag。这个是默认设置。设置<strong>false</strong>，禁用所有的ETag。</p>
			</td>
		</tr>
		<tr>
			<td>String</td>
			<td>如果是<strong>strong</strong>，使能strong ETag。如果是<strong>weak</strong>，启用<strong>weak</strong>&nbsp;ETag。</td>
		</tr>
		<tr>
			<td>Function</td>
			<td>
			<p>客户自定义ETag方法的实现. 如果你使用这个，请确保你自己知道你在干什么。</p>

			<pre>
app.set(&#39;etag&#39;, function (body, encoding) {
  return generateHash(body, encoding); // consider the function is defined
  })</pre>
			</td>
		</tr>
	</tbody>
</table>

<h4>app.use([path,], function [, function...])</h4>

<p>挂载<a href="http://expressjs.com/guide/using-middleware.html" target="_blank">中间件</a>方法到路径上。如果路径未指定，那么默认为&quot;/&quot;。</p>

<blockquote>
<p>一个路由将匹配任何路径如果这个路径以这个路由设置路径后紧跟着&quot;/&quot;。比如：<strong>app.use(&#39;/appale&#39;, ...)</strong>将匹配&quot;/apple&quot;，&quot;/apple/images&quot;，&quot;/apple/images/news&quot;等。</p>

<p>中间件中的<strong>req.originalUrl</strong>是<strong>req.baseUrl</strong>和<strong>req.path</strong>的组合，如下面的例子所示。</p>

<pre>
app.use(&#39;/admin&#39;, function(req, res, next) {
// GET &#39;http://www.example.com/admin/new&#39;
console.log(req.originalUrl); // &#39;/admin/new&#39;
console.log(req.baseUrl); // &#39;/admin&#39;
console.log(req.path);// &#39;/new&#39;
});</pre>
</blockquote>

<p>在一个路径上挂载一个中间件之后，每当请求的路径的前缀部分匹配了这个路由路径，那么这个中间件就会被执行。 由于默认的路径为<strong>/</strong>，中间件挂载没有指定路径，那么对于每个请求，这个中间件都会被执行。</p>

<pre>
 // this middleware will be executed for every request to the app.
app.use(function(req, res, next) {
    console.log(&#39;Time: %d&#39;, Date.now());
    next();
});</pre>

<p>中间件方法是顺序处理的，所以中间件包含的顺序是很重要的。</p>

<pre>
// this middleware will not allow the request to  go beyond it
app.use(function(req, res, next) {
    res.send(&#39;Hello World&#39;);
});
// this middleware will never reach this route
app.use(&#39;/&#39;, function(req, res) {
    res.send(&#39;Welcome&#39;);
});</pre>

<p>路径可以是代表路径的一串字符，一个路径模式，一个匹配路径的正则表达式，或者他们的一组集合。</p>

<p>下面是路径的简单的例子。</p>

<table>
	<thead>
		<tr>
			<th>类型</th>
			<th>实例</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Path</td>
			<td>
			<pre>
// will match paths starting with /abcd
app.use(&#39;/abcd&#39;, function (req, res, next) {
  next();
})</pre>
			</td>
		</tr>
		<tr>
			<td>Path Pattern</td>
			<td>
			<pre>
// will match paths starting with /abcd and /abd
app.use(&#39;/abc?d&#39;, function (req, res, next) {
  next();
})

// will match paths starting with /abcd, /abbcd, /abbbbbcd and so on
app.use(&#39;/ab+cd&#39;, function (req, res, next) {
  next();
})

// will match paths starting with /abcd, /abxcd, /abFOOcd, /abbArcd and so on
app.use(&#39;/ab\*cd&#39;, function (req, res, next) {
  next();
})

// will match paths starting with /ad and /abcd
app.use(&#39;/a(bc)?d&#39;, function (req, res, next) {
  next();
})</pre>
			</td>
		</tr>
		<tr>
			<td>Regular Expression</td>
			<td>
			<pre>
// will match paths starting with /abc and /xyz
app.use(/\/abc|\/xyz/, function (req, res, next) {
  next();
})</pre>
			</td>
		</tr>
		<tr>
			<td>Array</td>
			<td>
			<pre>
// will match paths starting with /abcd, /xyza, /lmn, and /pqr
app.use([&#39;/abcd&#39;, &#39;/xyza&#39;, /\/lmn|\/pqr/], function (req, res, next) {
  next();
})</pre>
			</td>
		</tr>
	</tbody>
</table>

<p>方法可以是一个中间件方法，一系列中间件方法，一组中间件方法或者他们的集合。由于router和app实现了中间件接口，你可以像使用其他任一中间件方法那样使用它们。</p>

<table>
	<thead>
		<tr>
			<th>用法</th>
			<th>实例</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>单个中间件</td>
			<td>你可以局部定义和挂载一个中间件。
			<pre>
app.use(function (req, res, next) {
  next();
})</pre>
			一个router是有效的中间件。

			<pre>
var router = express.Router();
router.get(&#39;/&#39;, function (req, res, next) {
  next();
})
app.use(router);</pre>
			一个Express程序是一个有效的中间件。

			<pre>
var subApp = express();
subApp.get(&#39;/&#39;, function (req, res, next) {
  next();
})
app.use(subApp);</pre>
			</td>
		</tr>
		<tr>
			<td>一系列中间件</td>
			<td>对于一个相同的挂载路径，你可以挂载超过一个的中间件。
			<pre>
var r1 = express.Router();
r1.get(&#39;/&#39;, function (req, res, next) {
  next();
})

var r2 = express.Router();
r2.get(&#39;/&#39;, function (req, res, next) {
  next();
})

app.use(r1, r2);</pre>
			</td>
		</tr>
		<tr>
			<td>Array</td>
			<td>在逻辑上使用一个数组来组织一组中间件。如果你传递一组中间件作为第一个或者唯一的参数，接着你需要指定挂载的路径。
			<pre>
var r1 = express.Router();
r1.get(&#39;/&#39;, function (req, res, next) {
  next();
})

var r2 = express.Router();
r2.get(&#39;/&#39;, function (req, res, next) {
  next();
})

app.use(&#39;/&#39;, [r1, r2]);</pre>
			</td>
		</tr>
		<tr>
			<td>Combination</td>
			<td>你可以组合下面的所有方法来挂载中间件。
			<pre>
function mw1(req, res, next) { next(); }
function mw2(req, res, next) { next(); }

var r1 = express.Router();
r1.get(&#39;/&#39;, function (req, res, next) { next(); });

var r2 = express.Router();
r2.get(&#39;/&#39;, function (req, res, next) { next(); });

var subApp = express();
subApp.get(&#39;/&#39;, function (req, res, next) { next(); });

app.use(mw1, [mw2, r1, r2], subApp);</pre>
			</td>
		</tr>
	</tbody>
</table>

<p>下面是一些例子，在Express程序中使用express.static中间件。</p>

<p>为程序托管位于程序目录下的public目录下的静态资源：</p>

<pre>
// GET /style.css etc
app.use(express.static(__dirname + &#39;/public&#39;));</pre>

<p>在<strong>/static</strong>路径下挂载中间件来提供静态资源托管服务，只当请求是以<strong>/static</strong>为前缀的时候。</p>

<pre>
// GET /static/style.css etc.
app.use(&#39;/static&#39;, express.static(express.__dirname + &#39;/public&#39;));</pre>

<p>通过在设置静态资源中间件之后加载日志中间件来关闭静态资源请求的日志。</p>

<pre>
app.use(express.static(__dirname + &#39;/public&#39;));
app.use(logger());</pre>

<p>托管静态资源从不同的路径，但<strong>./public</strong>路径比其他更容易被匹配：</p>

<pre>
app.use(express.static(__dirname + &#39;/public&#39;));
app.use(express.static(__dirname + &#39;/files&#39;));
app.use(express.static(__dirname + &#39;/uploads&#39;));</pre>

<h2>Request</h2>

<p><strong>req</strong>对象代表了一个HTTP请求，其具有一些属性来保存请求中的一些数据，比如<strong>query string</strong>，<strong>parameters</strong>，<strong>body</strong>，<strong>HTTP headers</strong>等等。在本文档中，按照惯例，这个对象总是简称为<strong>req</strong>(http响应简称为<strong>res</strong>)，但是它们实际的名字由这个回调方法在那里使用时的参数决定。 如下例子:</p>

<pre>
app.get(&#39;/user/:id&#39;, function(req, res) {
    res.send(&#39;user&#39; + req.params.id);
});</pre>

<p>其实你也可以这样写：</p>

<pre>
app.get(&#39;/user/:id&#39;, function(request, response) {
    response.send(&#39;user&#39; + request.params.id);
});</pre>

<h3>Properties</h3>

<p>在<strong>Express 4</strong>中，<strong>req.files</strong>默认在<strong>req</strong>对象中不再是可用的。为了通过<strong>req.files</strong>对象来获得上传的文件，你可以使用一个<strong>multipart-handling</strong>(多种处理的工具集)中间件，比如<strong>busboy</strong>，<strong>multer</strong>，<strong>formidable</strong>，<strong>multipraty</strong>，<strong>connect-multiparty</strong>或者<strong>pez</strong>。</p>

<h4>req.app</h4>

<p>这个属性持有<strong>express</strong>程序实例的一个引用，其可以作为中间件使用。</p>

<p>如果你按照这个模式，你创建一个模块导出一个中间件，这个中间件只在你的主文件中<strong>require()</strong>它，那么这个中间件可以通过<strong>req.app</strong>来获取express的实例。 例如:</p>

<pre>
// index.js
app.get(&quot;/viewdirectory&quot;, require(&#39;./mymiddleware.js&#39;));</pre>

<pre>
// mymiddleware.js
module.exports = function(req, res) {
    res.send(&#39;The views directory is &#39; + req.app.get(&#39;views&#39;));
};</pre>

<h4>req.baseUrl</h4>

<p>一个路由实例挂载的Url路径。</p>

<pre>
var greet = express.Router();
greet.get(&#39;/jp&#39;, function(req, res) {
    console.log(req.baseUrl); // greet
    res.send(&#39;Konichiwa!&#39;);
});
app.use(&#39;/greet&#39;, greet);</pre>

<p>即使你使用的路径模式或者一系列路径模式来加载路由，<strong>baseUrl</strong>属性返回匹配的字符串，而不是路由模式。下面的例子，<strong>greet</strong>路由被加载在两个路径模式上。</p>

<pre>
app.use([&#39;/gre+t&#39;, &#39;hel{2}o&#39;], greet); // load the on router on &#39;/gre+t&#39; and &#39;/hel{2}o&#39;</pre>

<p>当一个请求路径是<strong>/greet/jp</strong>，<strong>baseUrl</strong>是<strong>/greet</strong>，当一个请求路径是<strong>/hello/jp</strong>，<strong>req.baseUrl</strong>是<strong>/hello</strong>。&nbsp;<strong>req.baseUrl</strong>和<strong>app</strong>对象的<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_7">mountpath</a>属性相似，除了<strong>app.mountpath</strong>返回的是路径匹配模式。</p>

<h4>req.body</h4>

<p>在请求的body中保存的是提交的一对对键值数据。默认情况下，它是<strong>undefined</strong>，当你使用比如<strong>body-parser</strong>和<strong>multer</strong>这类解析<strong>body</strong>数据的中间件时，它是填充的。 下面的例子，给你展示了怎么使用<strong>body-parser</strong>中间件来填充<strong>req.body</strong>。</p>

<pre>
var app = require(&#39;express&#39;);
var bodyParser = require(&#39;body-parser&#39;);
var multer = require(&#39;multer&#39;)；// v1.0.5
var upload = multer(); // for parsing multipart/form-data
app.use(bodyParser.json()); // for parsing application/json
app.use(bodyParser.urlencoded({extended:true})); // for parsing application/x-www-form-urlencoded
app.post(&#39;/profile&#39;, upload.array(), function(req, res, next) {
    console.log(req.body);
    res.json(req.body);
});</pre>

<h4>req.cookies</h4>

<p>当使用cookie-parser中间件的时候，这个属性是一个对象，其包含了请求发送过来的cookies。如果请求没有带cookies，那么其值为{}。</p>

<pre>
// Cookie: name=tj
req.cookies.name
// =&gt; &quot;tj&quot;</pre>

<p>获取更多信息，问题，或者关注，可以查阅<a href="https://github.com/expressjs/cookie-parser" target="_blank">cookie-parser</a>。</p>

<h4>req.fresh</h4>

<p>指示这个请求是否是新鲜的。其和<strong>req.stale</strong>是相反的。 当<strong>cache-control</strong>请求头没有<strong>no-cache</strong>指示和下面中的任一一个条件为<strong>true</strong>，那么其就为<strong>true</strong>：</p>

<ul>
	<li><strong>if-modified-since</strong>请求头被指定，和<strong>last-modified</strong>请求头等于或者早于<strong>modified</strong>响应头。</li>
	<li><strong>if-none-match</strong>请求头是<strong>*</strong>。</li>
	<li><strong>if-none-match</strong>请求头在被解析进它的指令之后，和<strong>etag</strong>响应头的值不相等</li>
</ul>

<blockquote>
<p>ps:If-None-Match作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能</p>
</blockquote>

<pre>
req.fresh
// =&gt; true</pre>

<h4>req.hostname</h4>

<p>包含了源自<strong>Host</strong>HTTP头部的<strong>hostname</strong>。</p>

<p>当<strong>trust proxy</strong>设置项被设置为启用值，<strong>X-Forwarded-Host</strong>头部被使用来代替<strong>Host</strong>。这个头部可以被客户端或者代理设置。</p>

<pre>
// Host: &quot;example.com&quot;
req.hostname
// =&gt; &quot;example.com&quot;</pre>

<h4>req.ips</h4>

<p>当<strong>trust proxy</strong>设置项被设置为启用值，这个属性包含了一组在<strong>X-Forwarded-For</strong>请求头中指定的IP地址。不然，其就包含一个空的数组。这个头部可以被客户端或者代理设置。</p>

<p>例如，如果<strong>X-Forwarded-For</strong>是<strong>client</strong>，<strong>proxy1</strong>，<strong>proxy2</strong>，<strong>req.ips</strong>就是<strong>[&quot;clinet&quot;, &quot;proxy1&quot;, &quot;proxy2&quot;]</strong>，这里<strong>proxy2</strong>就是最远的下游。</p>

<h4>req.originalUrl</h4>

<blockquote>
<p><strong>req.url</strong>不是一个原生的<strong>Express</strong>属性，它继承自<a href="https://nodejs.org/api/http.html#http_message_url" target="_blank">Node&#39;s http module</a>。</p>
</blockquote>

<p>这个属性很像<strong>req.url</strong>；然而，其保留了原版的请求链接，允许你自由地重定向<strong>req.url</strong>到内部路由。比如，<strong>app.use()</strong>的<strong>mounting</strong>特点可以重定向<strong>req.url</strong>跳转到挂载点。</p>

<pre>
// GET /search?q=something
req.originalUrl
// =&gt; &quot;/search?q=something&quot;</pre>

<h4>req.params</h4>

<p>一个对象，其包含了一系列的属性，这些属性和在路由中命名的参数名是一一对应的。例如，如果你有<strong>/user/:name</strong>路由，<strong>name</strong>属性可作为<strong>req.params.name</strong>。这个对象默认值为<strong>{}</strong>。</p>

<pre>
// GET /user/tj
req.params.name
// =&gt; &quot;tj&quot;</pre>

<p>当你使用正则表达式来定义路由规则，捕获组的组合一般使用<strong>req.params[n]</strong>，这里的<strong>n</strong>是第几个捕获租。这个规则被施加在无名通配符匹配，比如<strong>/file/*</strong>的路由：</p>

<pre>
// GET /file/javascripts/jquery.js
req.params[0]
// =&gt; &quot;javascripts/jquery.js&quot;</pre>

<h4>req.path</h4>

<p>包含请求URL的部分路径。</p>

<pre>
// example.com/users?sort=desc
req.path
// =&gt; &quot;/users&quot;</pre>

<blockquote>
<p>当在一个中间件中被调用，挂载点不包含在<strong>req.path</strong>中。你可以查阅<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_25" target="_blank">app.use()</a>获得跟多的信息。</p>
</blockquote>

<h4>req.protocol</h4>

<p>请求的协议，一般为<strong>http</strong>，当启用TLS加密，则为<strong>https</strong>。</p>

<p>当<strong>trust proxy</strong>设置一个启用的参数，如果存在<strong>X-Forwarded-Proto</strong>头部的话，其将被信赖和使用。这个头部可以被客户端或者代理设置。</p>

<pre>
req.ptotocol
// =&gt; &quot;http&quot;</pre>

<h4>req.query</h4>

<p>一个对象，为每一个路由中的<strong>query string</strong>参数都分配一个属性。如果没有<strong>query string</strong>，它就是一个空对象，<strong>{}</strong>。</p>

<pre>
// GET /search?q=tobi+ferret
req.query.q
// =&gt; &quot;tobi ferret&quot;
// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse
req.query.order
// =&gt; &quot;desc&quot;
req.query.shoe.color
// =&gt; &quot;blue&quot;
req.query.shoe.type
// =&gt; &quot;converse&quot;</pre>

<h4>req.route</h4>

<p>当前匹配的路由，其为一串字符。比如：</p>

<pre>
app.get(&#39;/user/:id?&#39;, function userIdHandler(req, res) {
    console.log(req.route);
    res.send(&#39;GET&#39;)
})</pre>

<p>前面片段的输出为:</p>

<pre>
{ path:&quot;/user/:id?&quot;
    stack:
    [
        { handle:[Function:userIdHandler],
          name:&quot;userIdHandler&quot;,
          params:undefined,
          path:undefined,
          keys:[],
          regexp:/^\/?$/i,
          method:&#39;get&#39;
        }
    ]
    methods:{get:true}
}</pre>

<h4>req.secure</h4>

<p>一个布尔值，如果建立的是TLS的连接，那么就为<strong>true</strong>。等价于：</p>

<pre>
&#39;https&#39; == req.protocol;</pre>

<h4>req.signedCookies</h4>

<p>当使用<strong>cookie-parser</strong>中间件的时候，这个属性包含的是请求发过来的签名<strong>cookies</strong>，这个属性取得的是不含签名，可以直接使用的值。签名的<strong>cookies</strong>保存在不同的对象中来体现开发者的意图；不然，一个恶意攻击可以被施加在<strong>req.cookie</strong>值上(它是很容易被欺骗的)。记住，签名一个<strong>cookie</strong>不是把它藏起来或者加密；而是简单的防止篡改(因为签名使用的加密是私人的)。如果没有发送签名的<strong>cookie</strong>，那么这个属性默认为<strong>{}</strong>。</p>

<pre>
// Cookie： user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// =&gt; &quot;tobi&quot;</pre>

<p>为了获取更多的信息，问题或者关注，可以参阅<a href="https://github.com/expressjs/cookie-parser" target="_blank">cookie-parser</a>。</p>

<h4>req.stale</h4>

<p>指示这个请求是否是<strong>stale</strong>(陈旧的)，它与<strong>req.fresh</strong>是相反的。更多信息，可以查看<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_31">req.fresh</a>。</p>

<pre>
req.stale
// =&gt; true</pre>

<h4>req.subdomains</h4>

<p>请求中域名的子域名数组。</p>

<pre>
// Host: &quot;tobi.ferrets.example.com&quot;
req.subdomains
// =&gt; [&quot;ferrets&quot;, &quot;tobi&quot;]</pre>

<h4>req.xhr</h4>

<p>一个布尔值，如果<strong>X-Requested-With</strong>的值为<strong>XMLHttpRequest</strong>，那么其为<strong>true</strong>，其指示这个请求是被一个客服端库发送，比如<strong>jQuery</strong>。</p>

<pre>
req.xhr
// =&gt; true</pre>

<h3>Methods</h3>

<h4>req.accepts(types)</h4>

<p>检查这个指定的内容类型是否被接受，基于请求的Accept HTTP头部。这个方法返回最佳匹配，如果没有一个匹配，那么其返回undefined(在这个case下，服务器端应该返回406和&quot;Not Acceptable&quot;)。</p>

<p>type值可以是一个单的MIME type字符串(比如application/json)，一个扩展名比如json，一个逗号分隔的列表，或者一个数组。对于一个列表或者数组，这个方法返回最佳项(如果有的话)。</p>

<pre>
// Accept: text/html
req.accepts(&#39;html&#39;);
// =&gt; &quot;html&quot;
// Accept: text/*, application/json
req.accepts(&#39;html&#39;);
// =&gt; &quot;html&quot;
req.accepts(&#39;text/html&#39;);
// =&gt; &quot;text/html&quot;
req.accepts([&#39;json&#39;, &#39;text&#39;]);
// =&gt; &quot;json&quot;
req.accepts(&#39;application/json&#39;);
// =&gt; &quot;application/json&quot;
// Accept: text/*, application/json
req.accepts(&#39;image/png&#39;);
req.accepts(&#39;png&#39;);
// =&gt; undefined
// Accept: text/*;q=.5, application/json
req.accepts([&#39;html&#39;, &#39;json&#39;]);
// =&gt; &quot;json&quot;</pre>

<p>获取更多信息，或者如果你有问题或关注，可以参阅<a href="https://github.com/expressjs/accepts" target="_blank">accepts</a>。</p>

<h4>req.acceptsCharsets(charset[, ...])</h4>

<p>返回指定的字符集集合中第一个的配置的字符集，基于请求的<strong>Accept-Charset</strong>HTTP头。如果指定的字符集没有匹配的，那么就返回false。 获取更多信息，或者如果你有问题或关注，可以参阅<a href="https://github.com/expressjs/accepts" target="_blank">accepts</a>。</p>

<h4>req.acceptsEncodings(encoding[, ...])</h4>

<p>返回指定的编码集合中第一个的配置的编码，基于请求的<strong>Accept-Encoding</strong>HTTP头。如果指定的编码集没有匹配的，那么就返回false。 获取更多信息，或者如果你有问题或关注，可以参阅<a href="https://github.com/expressjs/accepts" target="_blank">accepts</a>。</p>

<h4>req.acceptsLanguages(lang [, ...])</h4>

<p>返回指定的语言集合中第一个的配置的语言，基于请求的<strong>Accept-Language</strong>HTTP头。如果指定的语言集没有匹配的，那么就返回false。 获取更多信息，或者如果你有问题或关注，可以参阅<a href="https://github.com/expressjs/accepts" target="_blank">accepts</a>。</p>

<h4>req.get(field)</h4>

<p>返回指定的请求HTTP头部的域内容(不区分大小写)。<strong>Referrer</strong>和<strong>Referer</strong>的域内容可互换。</p>

<pre>
req.get(&#39;Content-type&#39;);
// =&gt; &quot;text/plain&quot;
req.get(&#39;content-type&#39;);
// =&gt; &quot;text/plain&quot;
req.get(&#39;Something&#39;)
// =&gt; undefined</pre>

<p>其是req.header(field)的别名。</p>

<h4>req.is(type)</h4>

<p>如果进来的请求的<strong>Content-type</strong>头部域匹配参数<strong>type</strong>给定的<strong>MIME type</strong>，那么其返回<strong>true</strong>。否则返回<strong>false</strong>。</p>

<pre>
// With Content-Type: text/html; charset=utf-8
req.is(&#39;html&#39;);
req.is(&#39;text/html&#39;);
req.is(&#39;text/*&#39;);
// =&gt; true
// When Content-Type is application/json
req.is(&#39;json&#39;);
req.is(&#39;application/json&#39;);
req.is(&#39;application/*&#39;);
// =&gt; true
req.is(&#39;html&#39;);
// =&gt; false</pre>

<p>获取更多信息，或者如果你有问题或关注，可以参阅<a href="https://github.com/expressjs/type-is" target="_blank">type-is</a>。</p>

<h4>req.param(naem, [, defaultValue])</h4>

<blockquote>
<p>过时的。可以在适合的情况下，使用<strong>req.params</strong>，<strong>req.body</strong>或者<strong>req.query</strong>。</p>
</blockquote>

<p>返回当前参数<strong>name</strong>的值。</p>

<pre>
// ?name=tobi
req.param(&#39;name&#39;)
// =&gt; &quot;tobi&quot;
// POST name=tobi
req.param(&#39;name&#39;)
// =&gt; &quot;tobi&quot;
// /user/tobi for /user/:name
req.param(&#39;name&#39;)
// =&gt; &quot;tobi&quot;</pre>

<p>按下面给出的顺序查找：</p>

<ul>
	<li>req.params</li>
	<li>req.body</li>
	<li>req.query</li>
</ul>

<p>可选的，你可以指定一个<strong>defaultValue</strong>来设置一个默认值，如果这个参数在任何一个请求的对象中都不能找到。</p>

<blockquote>
<p>直接通过<strong>req.params</strong>，<strong>req.body</strong>，<strong>req.query</strong>取得应该更加的清晰-除非你确定每一个对象的输入。&nbsp;<strong>Body-parser</strong>中间件必须加载，如果你使用<strong>req.param()</strong>。详细请看<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_30" target="_blank">req.body</a>。</p>
</blockquote>

<h2>Response</h2>

<p><strong>res</strong>对象代表了当一个HTTP请求到来时，<strong>Express</strong>程序返回的HTTP响应。在本文档中，按照惯例，这个对象总是简称为<strong>res</strong>(http请求简称为<strong>req</strong>)，但是它们实际的名字由这个回调方法在那里使用时的参数决定。 例如：</p>

<pre>
app.get(&#39;/user/:id&#39;, function(req, res) {
    res.send(&#39;user&#39; + req.params.id);
});</pre>

<p>这样写也是一样的：</p>

<pre>
app.get(&#39;/user/:id&#39;, function(request, response) {
    response.send(&#39;user&#39; + request.params.id);
});</pre>

<h3>Properties</h3>

<h4>res.app</h4>

<p>这个属性持有express程序实例的一个引用，其可以在中间件中使用。</p>

<p>res.app和请求对象中的req.app属性是相同的。/p&gt;</p>

<h4>res.headersSent</h4>

<p>布尔类型的属性，指示这个响应是否已经发送HTTP头部。</p>

<pre>
app.get(&#39;/&#39;, function(req, res) {
    console.log(res.headersSent); // false
    res.send(&#39;OK&#39;); // send之后就发送了头部
    console.log(res.headersSent); // true
});</pre>

<h4>res.locals</h4>

<p>一个对象，其包含了本次请求的响应中的变量和因此它的变量只提供给本次请求响应的周期内视图渲染里使用(如果有视图的话)。 其他方面，其和<strong>app.locals</strong>是一样的。</p>

<p>这个参数在导出请求级别的信息是很有效的，这些信息比如请求路径，已认证的用户，用户设置等等。</p>

<pre>
app.use(function(req, res, next) {
    res.locals.user = req.user;
    res.locals.authenticated = !req.user.anonymous;
    next();
});</pre>

<h3>Methods</h3>

<h4>res.append(field [, value])</h4>

<blockquote>
<p>res.append()方法在<strong>Expresxs</strong>4.11.0以上版本才支持。</p>
</blockquote>

<p>在指定的<strong>field</strong>的HTTP头部追加特殊的值<strong>value</strong>。如果这个头部没有被设置，那么将用<strong>value</strong>新建这个头部。<strong>value</strong>可以是一个字符串或者数组。</p>

<p>注意：在<strong>res.append()</strong>之后调用<strong>app.set()</strong>函数将重置前面设置的值。</p>

<pre>
res.append(&#39;Lind&#39;, [&#39;&lt;http://localhost&gt;&#39;, &#39;&lt;http://localhost:3000&gt;&#39;]);
res.append(&#39;Set-Cookie&#39;, &#39;foo=bar;Path=/;HttpOnly&#39;);
res.append(&#39;Warning&#39;, &#39;199 Miscellaneous warning&#39;);</pre>

<h4>res.attachment([filename])</h4>

<p>设置HTTP响应的<strong>Content-Disposition</strong>头内容为&quot;attachment&quot;。如果提供了<strong>filename</strong>，那么将通过<strong>res.type()</strong>获得扩展名来设置<strong>Content-Type</strong>，并且设置<strong>Content-Disposition</strong>内容为&quot;filename=&quot;parameter。</p>

<pre>
res.attachment();
// Content-Disposition: attachment
res.attachment(&#39;path/to/logo.png&#39;);
// Content-Disposition: attachment; filename=&quot;logo.png&quot;
// Content-Type: image/png</pre>

<h4>res.cookie(name, value [,options])</h4>

<p>设置<strong>name</strong>和<strong>value</strong>的<strong>cookie</strong>，<strong>value</strong>参数可以是一串字符或者是转化为json字符串的对象。</p>

<p>options是一个对象，其可以有下列的属性。</p>

<table>
	<thead>
		<tr>
			<th>属性</th>
			<th>类型</th>
			<th>描述</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>domain</td>
			<td>String</td>
			<td>设置cookie的域名。默认是你本app的域名。</td>
		</tr>
		<tr>
			<td>expires</td>
			<td>Date</td>
			<td>cookie的过期时间，GMT格式。如果没有指定或者设置为0，则产生新的cookie。</td>
		</tr>
		<tr>
			<td>httpOnly</td>
			<td>Boolean</td>
			<td>这个cookie只能被web服务器获取的标示。</td>
		</tr>
		<tr>
			<td>maxAge</td>
			<td>String</td>
			<td>是设置过去时间的方便选项，其为过期时间到当前时间的毫秒值。</td>
		</tr>
		<tr>
			<td>path</td>
			<td>String</td>
			<td>cookie的路径。默认值是<strong>/</strong>。</td>
		</tr>
		<tr>
			<td>secure</td>
			<td>Boolean</td>
			<td>标示这个cookie只用被<strong>HTTPS</strong>协议使用。</td>
		</tr>
		<tr>
			<td>signed</td>
			<td>Boolean</td>
			<td>指示这个cookie应该是签名的。</td>
		</tr>
	</tbody>
</table>

<blockquote>
<p>res.cookie()所作的都是基于提供的<strong>options</strong>参数来设置<strong>Set-Cookie</strong>头部。没有指定任何的<strong>options</strong>，那么默认值在<strong>RFC6265</strong>中指定。</p>
</blockquote>

<p>使用实例：</p>

<pre>
res.cookie(&#39;name&#39;, &#39;tobi&#39;, {&#39;domain&#39;:&#39;.example.com&#39;, &#39;path&#39;:&#39;/admin&#39;, &#39;secure&#39;:true});
res.cookie(&#39;remenberme&#39;, &#39;1&#39;, {&#39;expires&#39;:new Date(Date.now() + 90000), &#39;httpOnly&#39;:true});</pre>

<p>maxAge 是一个方便设置过期时间的方便的选项，其以当前时间开始的毫秒数来计算。下面的示例和上面的第二条功效一样。</p>

<pre>
res.cookie(&#39;rememberme&#39;, &#39;1&#39;, {&#39;maxAge&#39;:90000}, &quot;httpOnly&quot;:true);</pre>

<p>你可以设置传递一个对象作为value的参数。然后其将被序列化为Json字符串，被bodyParser()中间件解析。</p>

<pre>
res.cookie(&#39;cart&#39;, {&#39;items&#39;:[1, 2, 3]});
res.cookie(&#39;cart&#39;, {&#39;items&#39;:[1, 2, 3]}, {&#39;maxAge&#39;:90000});</pre>

<p>当我们使用cookie-parser中间件的时候，这个方法也支持签名的cookie。简单地，在设置options时包含signed选项为true。然后res.cookie()将使用传递给cookieParser(secret)的密钥来签名这个值。</p>

<pre>
res.cookie(&#39;name&#39;, &#39;tobi&#39;, {&#39;signed&#39;:true});</pre>

<h4>res.clearCookie(name [,options])</h4>

<p>根据指定的<strong>name</strong>清除对应的cookie。更多关于<strong>options</strong>对象可以查阅<strong>res.cookie()</strong>。</p>

<pre>
res.cookie(&#39;name&#39;, &#39;tobi&#39;, {&#39;path&#39;:&#39;/admin&#39;});
res.clearCookie(&#39;name&#39;, {&#39;path&#39;:&#39;admin&#39;});</pre>

<h4>res.download(path, [,filename], [,fn])</h4>

<p>传输<strong>path</strong>指定文件作为一个附件。通常，浏览器提示用户下载。默认情况下，<strong>Content-Disposition</strong>头部&quot;filename=&quot;的参数为<strong>path</strong>(通常会出现在浏览器的对话框中)。通过指定<strong>filename</strong>参数来覆盖默认值。</p>

<p>当一个错误发生时或者传输完成，这个方法将调用<strong>fn</strong>指定的回调方法。这个方法使用<strong>res.sendFile()</strong>来传输文件。</p>

<pre>
res.download(&#39;/report-12345.pdf&#39;);
res.download(&#39;/report-12345.pdf&#39;, &#39;report.pdf&#39;);
res.download(&#39;report-12345.pdf&#39;, &#39;report.pdf&#39;, function(err) {
// Handle error, but keep in mind the response may be partially-sent
// so check res.headersSent
if (err) {
} else {
// decrement a download credit, etc.
}
});</pre>

<h4>res.end([data] [, encoding])</h4>

<p>结束本响应的过程。这个方法实际上来自<strong>Node</strong>核心模块，具体的是<a href="https://nodejs.org/api/http.html#http_response_end_data_encoding_callback" target="_blank">response.end() method of http.ServerResponse</a>。</p>

<p>&nbsp;</p>

<p>用来快速结束请求，没有任何的数据。如果你需要发送数据，可以使用<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_67">res.send()</a>和<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_62" target="_blank">res.json()</a>这类的方法。</p>

<pre>
res.end();
res.status(404).end();</pre>

<h4>res.format(object)</h4>

<p>进行内容协商，根据请求的对象中<strong>Accept</strong>HTTP头部指定的接受内容。它使用 req.accepts()来选择一个句柄来为请求服务，这些句柄按质量值进行排序。如果这个头部没有指定，那么第一个方法默认被调用。当不匹配时，服务器将返回<strong>406</strong>&quot;Not Acceptable&quot;，或者调用<strong>default</strong>回调。</p>

<p><strong>Content-Type</strong>请求头被设置，当一个回调方法被选择。然而你可以改变他，在这个方法中使用这些方法，比如<strong>res.set()</strong>或者<strong>res.type()</strong>。</p>

<p>下面的例子，将回复<strong>{&quot;message&quot;:&quot;hey&quot;}</strong>，当请求的对象中<strong>Accept</strong>头部设置成&quot;application/json&quot;或者&quot;*/json&quot;(不过如果是<strong>*/*</strong>，然后这个回复就是&quot;hey&quot;)。</p>

<pre>
res.format({
    &#39;text/plain&#39;:function() {
        res.send(&#39;hey&#39;);
    },
    &#39;text/html&#39;:function() {
        res.send(&#39;&lt;p&gt;hey&lt;/p&gt;&#39;);
    },
    &#39;application/json&#39;:function() {
        res.send({message:&#39;hey&#39;});
    },
    &#39;default&#39;:function() {
        res.status(406).send(&#39;Not Acceptable&#39;);
    }
})</pre>

<p>除了规范化的MIME类型之外，你也可以使用拓展名来映射这些类型来避免冗长的实现：</p>

<pre>
res.format({
    text:function() {
        res.send(&#39;hey&#39;);
    },
    html:function() {
        res.send(&#39;&lt;p&gt;hey&lt;/p&gt;&#39;);
    },
    json:function() {
        res.send({message:&#39;hey&#39;});
    }
})</pre>

<h4>res.get(field)</h4>

<p>返回<strong>field</strong>指定的HTTP响应的头部。匹配是区分大小写。</p>

<pre>
res.get(&#39;Content-Type&#39;);
// =&gt; &quot;text/plain&quot;</pre>

<h4>res.json([body])</h4>

<p>发送一个json的响应。这个方法和将一个对象或者一个数组作为参数传递给<strong>res.send()</strong>方法的效果相同。不过，你可以使用这个方法来转换其他的值到json，例如<strong>null</strong>，<strong>undefined</strong>。(虽然这些都是技术上无效的JSON)。</p>

<pre>
res.json(null);
res.json({user:&#39;tobi&#39;});
res.status(500).json({error:&#39;message&#39;});</pre>

<h4>res.jsonp([body])</h4>

<p>发送一个json的响应，并且支持JSONP。这个方法和res.json()效果相同，除了其在选项中支持JSONP回调。</p>

<pre>
res.jsonp(null)
// =&gt; null
res.jsonp({user:&#39;tobi&#39;})
// =&gt; {&quot;user&quot; : &quot;tobi&quot;}
res.status(500).jsonp({error:&#39;message&#39;})
// =&gt; {&quot;error&quot; : &quot;message&quot;}</pre>

<p>默认情况下，jsonp的回调方法简单写作callback。可以通过<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table">jsonp callback name</a>设置来重写它。</p>

<p>下面是一些例子使用JSONP响应，使用相同的代码:</p>

<pre>
// ?callback=foo
res.jsonp({user:&#39;tobo&#39;})
// =&gt; foo({&quot;user&quot;:&quot;tobi&quot;})
app.set(&#39;jsonp callback name&#39;, &#39;cb&#39;)
// ?cb=foo
res.status(500).jsonp({error:&#39;message&#39;})
// =&gt; foo({&quot;error&quot;:&quot;message&quot;})</pre>

<h4>res.links(links)</h4>

<p>连接这些<strong>links</strong>，<strong>links</strong>是以传入参数的属性形式提供，连接之后的内容用来填充响应的Link HTTP头部。</p>

<pre>
res.links({
    next:&#39;http://api.example.com/users?page=2&#39;,
    last:&#39;http://api.example.com/user?page=5&#39;
});</pre>

<p>效果：</p>

<pre>
Link:&lt;http://api.example.com/users?page=2&gt;;rel=&quot;next&quot;,
&lt;http://api.example.com/users?page=5&gt;;rel=&quot;last&quot;</pre>

<h4>res.location(path)</h4>

<p>设置响应的<strong>Location</strong>HTTP头部为指定的<strong>path</strong>参数。</p>

<pre>
res.location(&#39;/foo/bar&#39;);
res.location(&#39;http://example.com&#39;);
res.location(&#39;back&#39;);</pre>

<p>当<strong>path</strong>参数为<strong>back</strong>时，其具有特殊的意义，其指定URL为请求对象的<strong>Referer</strong>头部指定的URL。如果请求中没有指定，那么其即为&quot;/&quot;。</p>

<blockquote>
<p>Express传递指定的URL字符串作为回复给浏览器响应中的<strong>Location</strong>头部的值，不检测和操作，除了<strong>back</strong>这个参数。浏览器会将用户重定向到<strong>location</strong>设置的url或者<strong>Referer</strong>的url（<strong>back</strong>参数的情况）</p>
</blockquote>

<h4>res.redirect([status,] path)</h4>

<p>重定向来源于指定<strong>path</strong>的URL，以及指定的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank">HTTP status code</a><strong>status</strong>。如果你没有指定<strong>status</strong>，status code默认为&quot;302 Found&quot;。</p>

<pre>
res.redirect(&#39;/foo/bar&#39;);
res.redirect(&#39;http://example.com&#39;);
res.redirect(301, &#39;http://example.com&#39;);
res.redirect(&#39;../login&#39;);</pre>

<p>重定向也可以是完整的URL，来重定向到不同的站点。</p>

<pre>
res.redirect(&#39;http://google.com&#39;);&lt;/p&gt;&lt;p&gt;
重定向也可以相对于主机的根路径。比如，如果程序的路径为&lt;strong&gt;http://example.com/admin/post/new&lt;/strong&gt;，那么下面将重定向到&lt;strong&gt;http://example.com/admim&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;res.redirect(&#39;/admin&#39;);</pre>

<p>重定向也可以相对于当前的URL。比如，来之于<strong>http://example.com/blog/admin/</strong>(注意结尾的<strong>/</strong>)，下面将重定向到<strong>http://example.com/blog/admin/post/new</strong>。</p>

<pre>
res.redirect(&#39;post/new&#39;);</pre>

<p>如果来至于<strong>http://example.com/blog/admin</strong>（没有尾部<strong>/</strong>），重定向<strong>post/new</strong>，将重定向到<strong>http://example.com/blog/post/new</strong>。如果你觉得上面很混乱，可以把路径段认为目录(有&#39;/&#39;)或者文件，这样是可以的。相对路径的重定向也是可以的。如果你当前的路径为<strong>http://example.com/admin/post/new</strong>，下面的操作将重定向到<strong>http://example.com/admin/post</strong>：</p>

<pre>
res.redirect(&#39;..&#39;);</pre>

<p><strong>back</strong>将重定向请求到<a href="http://en.wikipedia.org/wiki/HTTP_referer" target="_blank">referer</a>，当没有<strong>referer</strong>的时候，默认为<strong>/</strong>。</p>

<pre>
res.redirect(&#39;back&#39;);</pre>

<h4>res.render(view [, locals] [, callback])</h4>

<p>渲染一个视图，然后将渲染得到的HTML文档发送给客户端。可选的参数为:</p>

<ul>
	<li><strong>locals</strong>，定义了视图本地参数属性的一个对象。</li>
	<li><strong>callback</strong>，一个回调方法。如果提供了这个参数，<strong>render</strong>方法将返回错误和渲染之后的模板，并且不自动发送响应。当有错误发生时，可以在这个回调内部，调用<strong>next(err)</strong>方法。</li>
</ul>

<blockquote>
<p>本地变量缓存使能视图缓存。在开发环境中缓存视图，需要手动设置为true；视图缓存在生产环境中默认开启。</p>
</blockquote>

<pre>
// send the rendered view to the client
res.render(&#39;index&#39;);
// if a callback is specified, the render HTML string has to be sent explicitly
res.render(&#39;index&#39;, function(err, html) {
    res.send(html);
});
// pass a local variable to  the view
res.render(&#39;user&#39;, {name:&#39;Tobi&#39;}, function(err, html) {
    // ...
});</pre>

<h4>res.send([body])</h4>

<p>发送HTTP响应。</p>

<p><strong>body</strong>参数可以是一个<strong>Buffer</strong>对象，一个字符串，一个对象，或者一个数组。比如：</p>

<pre>
res.send(new Buffer(&#39;whoop&#39;));
res.send({some:&#39;json&#39;});
res.send(&#39;&lt;p&gt;some html&lt;/p&gt;&#39;);
res.status(404).send(&#39;Sorry, we cannot find that!&#39;);
res.status(500).send({ error: &#39;something blew up&#39; });</pre>

<p>对于一般的非流请求，这个方法可以执行许多有用的的任务：比如，它自动给Content-LengthHTTP响应头赋值(除非先前定义)，也支持自动的HEAD和HTTP缓存更新。</p>

<p>当参数是一个Buffer对象，这个方法设置Content-Type响应头为application/octet-stream，除非事先提供，如下所示:</p>

<pre>
res.set(&#39;Content-Type&#39;, &#39;text/html&#39;);
res.send(new Buffer(&#39;&lt;p&gt;some html&lt;/p&gt;&#39;));</pre>

<p>当参数是一个字符串，这个方法设置Content-Type响应头为text/html：</p>

<pre>
res.send(&#39;&lt;p&gt;some html&lt;/p&gt;&#39;);</pre>

<p>当参数是一个对象或者数组，Express使用JSON格式来表示：</p>

<pre>
res.send({user:&#39;tobi&#39;});
res.send([1, 2, 3]);</pre>

<h4>res.sendFile(path [, options] [, fn])</h4>

<blockquote>
<p><strong>res.sendFile()</strong>从<strong>Express v4.8.0</strong>开始支持。</p>
</blockquote>

<p>传输<strong>path</strong>指定的文件。根据文件的扩展名设置<strong>Content-Type</strong>HTTP头部。除非在<strong>options</strong>中有关于<strong>root</strong>的设置，<strong>path</strong>一定是关于文件的绝对路径。 下面的表提供了<strong>options</strong>参数的细节:</p>

<table>
	<thead>
		<tr>
			<th>属性</th>
			<th>描述</th>
			<th>默认值</th>
			<th>可用版本</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>maxAge</td>
			<td>设置<strong>Cache-Control</strong>的<strong>max-age</strong>属性，格式为毫秒数，或者是<a href="https://www.npmjs.org/package/ms" target="_blank">ms format</a>的一串字符串</td>
			<td>0</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>root</td>
			<td>相对文件名的根目录</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>lastModified</td>
			<td>设置<strong>Last-Modified</strong>头部为此文件在系统中的最后一次修改时间。设置<strong>false</strong>来禁用它</td>
			<td>Enable</td>
			<td>4.9.0+</td>
		</tr>
		<tr>
			<td>headers</td>
			<td>一个对象，包含了文件相关的HTTP头部。</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>dotfiles</td>
			<td>是否支持点开头文件名的选项。可选的值&quot;allow&quot;,&quot;deny&quot;,&quot;ignore&quot;</td>
			<td>&quot;ignore&quot;</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>

<p>当传输完成或者发生了什么错误，这个方法调用<strong>fn</strong>回调方法。如果这个回调参数指定了和一个错误发生，回调方法必须明确地通过结束请求-响应循环或者传递控制到下个路由来处理响应过程。</p>

<p>下面是使用了所有参数的使用<strong>res.sendFile()</strong>的例子：</p>

<pre>
app.get(&#39;/file/:name&#39;, function(req, res, next) {
    var options = {
        root:__dirname + &#39;/public&#39;,
        dotfile:&#39;deny&#39;,
        headers:{
            &#39;x-timestamp&#39;:Date.now(),
            &#39;x-sent&#39;:true
        }
    };
    var fileName = req.params.name;
    res.sendFile(fileName, options, function(err) {
        if (err) {
            console.log(err);
            res.status(err.status).end();
        }
        else {
            console.log(&#39;sent&#39;, fileName);
        }
    });
});</pre>

<p>res.sendFile提供了文件服务的细粒度支持，如下例子说明：</p>

<pre>
app.get(&#39;/user/:uid/photos/:file&#39;, function(req, res) {
    var uid = req.params.uid
        , file = req.params.file;
    req.user.mayViewFilesFrom(uid, function(yes) {
        if (yes) {
            res.sendFile(&#39;/upload/&#39; + uid + &#39;/&#39; + file);
        }
        else {
            res.status(403).send(&#39;Sorry! you cant see that.&#39;);
        }
    });
})</pre>

<p>获取更多信息，或者你有问题或者关注，可以查阅<a href="https://github.com/pillarjs/send" target="_blank">send</a>。</p>

<h4>res.sendStatus(statusCode)</h4>

<p>设置响应对象的<strong>HTTP status code</strong>为<strong>statusCode</strong>并且发送<strong>statusCode</strong>的相应的字符串形式作为响应的Body。</p>

<pre>
res.sendStatus(200); // equivalent to res.status(200).send(&#39;OK&#39;);
res.sendStatus(403); // equivalent to res.status(403).send(&#39;Forbidden&#39;);
res.sendStatus(404); // equivalent to res.status(404).send(&#39;Not Found&#39;);
res.sendStatus(500); // equivalent to res.status(500).send(&#39;Internal Server Error&#39;)</pre>

<p>如果一个不支持的状态被指定，这个HTTP status依然被设置为<strong>statusCode</strong>并且用这个code的字符串作为Body。</p>

<pre>
res.sendStatus(2000); // equivalent to res.status(2000).send(&#39;2000&#39;);</pre>

<p><a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank">More about HTTP Status Codes</a></p>

<p>&nbsp;</p>

<h4>res.set(field [, value])</h4>

<p>设置响应对象的HTTP头部<strong>field</strong>为<strong>value</strong>。为了一次设置多个值，那么可以传递一个对象为参数。</p>

<pre>
res.set(&#39;Content-Type&#39;, &#39;text/plain&#39;);
res.set({
    &#39;Content-Type&#39;:&#39;text/plain&#39;,
    &#39;Content-Length&#39;:&#39;123&#39;,
    &#39;ETag&#39;:&#39;123456&#39;
})</pre>

<p>其和res.header(field [,value])效果一致。</p>

<h4>res.status(code)</h4>

<p>使用这个方法来设置响应对象的HTTP status。其是Node中<a href="http://nodejs.org/api/http.html#http_response_statuscode" target="_blank">response.statusCode</a>的一个连贯性的别名。</p>

<pre>
res.status(403).end();
res.status(400).send(&#39;Bad Request&#39;);
res.status(404).sendFile(&#39;/absolute/path/to/404.png&#39;);</pre>

<h4>res.type(type)</h4>

<p>程序将设置<strong>Content-Type</strong>HTTP头部的MIME type，如果这个设置的<strong>type</strong>能够被<a href="https://github.com/broofa/node-mime" target="_blank">mime.lookup</a>解析成正确的<strong>Content-Type</strong>。如果<strong>type</strong>中包含了<strong>/</strong>字符，那么程序会直接设置<strong>Content-Type</strong>为<strong>type</strong>。</p>

<pre>
res.type(&#39;.html&#39;);              // =&gt; &#39;text/html&#39;
res.type(&#39;html&#39;);               // =&gt; &#39;text/html&#39;
res.type(&#39;json&#39;);               // =&gt; &#39;application/json&#39;
res.type(&#39;application/json&#39;);   // =&gt; &#39;application/json&#39;
res.type(&#39;png&#39;);                // =&gt; image/png:</pre>

<h4>res.vary(field)</h4>

<p>在没有Vary应答头部时增加Vary应答头部。</p>

<blockquote>
<p>ps：vary的意义在于告诉代理服务器/缓存/CDN，如何判断请求是否一样，vary中的组合就是服务器/缓存/CDN判断的依据，比如Vary中有User-Agent，那么即使相同的请求，如果用户使用IE打开了一个页面，再用Firefox打开这个页面的时候，CDN/代理会认为是不同的页面，如果Vary中没有User-Agent，那么CDN/代理会认为是相同的页面，直接给用户返回缓存的页面，而不会再去web服务器请求相应的页面。通俗的说就相当于<strong>field</strong>作为了一个缓存的key来判断是否命中缓存</p>
</blockquote>

<pre>
res.vary(&#39;User-Agent&#39;).render(&#39;docs&#39;);</pre>

<h2>Router</h2>

<blockquote>
<p>一个<strong>router</strong>对象是一个单独的实例关于中间件和路由。你可以认为其是一个&quot;mini-application&quot;（迷你程序），其具有操作中间件和路由方法的能力。每个<strong>Express</strong>程序有一个内建的app路由。 路由自身表现为一个中间件，所以你可以使用它作为<strong>app.use()</strong>方法的一个参数或者作为另一个路由的<strong>use()</strong>的参数。 顶层的<strong>express</strong>对象有一个<strong>Router()</strong>方法，你可以使用<strong>Router()</strong>来创建一个新的<strong>router</strong>对象。</p>
</blockquote>

<pre>
res.vary(&#39;User-Agent&#39;).render(&#39;docs&#39;);</pre>

<h4>Router([options])</h4>

<p>如下，可以创建一个路由：</p>

<pre>
var router = express.Router([options]);</pre>

<p><strong>options</strong>参数可以指定路由的行为，其有下列选择：</p>

<table>
	<thead>
		<tr>
			<th>属性</th>
			<th>描述</th>
			<th>默认值</th>
			<th>可用性</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>caseSensitive</td>
			<td>是否区分大小写</td>
			<td>默认不启用。对待<strong>/Foo</strong>和<strong>/foo</strong>一样。</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>mergeParams</td>
			<td>保存父路由的<strong>res.params</strong>。如果父路由参数和子路由参数冲突，子路由参数优先。</td>
			<td>false</td>
			<td>4.5.0+</td>
		</tr>
		<tr>
			<td>strict</td>
			<td>使能严格路由。</td>
			<td>默认不启用，<strong>/foo</strong>和<strong>/foo/</strong>被路由一样对待处理</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>

<p>你可以将<strong>router</strong>当作一个程序，可以在其上添加中间件和HTTP路由方法(例如<strong>get</strong>，<strong>put</strong>，<strong>post</strong>等等)。</p>

<pre>
// invoked for any requests passed to this router
router.use(function(req, res, next) {
  // .. some logic here .. like any other middleware
  next();
});
// will handle any request that ends in /events
// depends on where the router is &quot;use()&#39;d&quot;
router.get(&#39;/events&#39;, function(req, res, next) {
  // ..
});</pre>

<p>你可以在一个特别的根URL上挂载一个路由，这样你就以将你的各个路由放到不同的文件中或者甚至是mini的程序。</p>

<pre>
// only requests to /calendar/* will be sent to our &quot;router&quot;
app.use(&#39;/calendar&#39;, router);</pre>

<h3>Methods</h3>

<h4>router.all(path, [callback, ...] callback)</h4>

<p>这个方法和<strong>router.METHOD()</strong>方法一样，除了这个方法会匹配所有的HTTP动作。</p>

<p>这个方法对想映射全局的逻辑处理到特殊的路径前缀或者任意匹配是十分有用的。比如，如果你放置下面所示的这个路由在其他路由的前面，那么其将要求从这个点开始的所有的路由进行验证操作和自动加载用户信息。记住，这些全局的逻辑操作，不需要结束请求响应周期：<strong>loaduser</strong>可以执行一个任务，然后调用<strong>next()</strong>来将执行流程移交到随后的路由。</p>

<pre>
router.all(&#39;*&#39;, requireAuthentication, loadUser);</pre>

<p>相等的形式:</p>

<pre>
router.all(&#39;*&#39;, requireAuthentication)
router.all(&#39;*&#39;, loadUser);</pre>

<p>这是一个白名单全局功能的例子。这个例子很像前面的，不过其仅仅作用于以<strong>/api</strong>开头的路径:</p>

<pre>
router.all(&#39;/api/*&#39;, requireAuthentication);</pre>

<h4>router.METHOD(path, [callback, ...] callback)</h4>

<p><strong>router.METHOD()</strong>方法提供了路由方法在<strong>Express</strong>中，这里的<strong>METHOD</strong>是HTTP方法中的一个，比如<strong>GET</strong>，<strong>PUT</strong>，<strong>POST</strong>等等，但<strong>router</strong>中的METHOD是小写的。所以，实际的方法是<strong>router.get()</strong>，<strong>router.put()</strong>，<strong>router.post()</strong>等等。</p>

<p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用<strong>next(&#39;router&#39;)</strong>来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没有满足当前路由的处理条件，那么传递控制到随后的路由。</p>

<p>下面的片段可能说明了最简单的路由定义。Experss转换path字符串为正则表达式，用于内部匹配传入的请求。在匹配的时候，是不考虑<strong>Query strings</strong>，例如，&quot;GET /&quot;将匹配下面的路由，&quot;GET /?name=tobi&quot;也是一样的。</p>

<pre>
router.get(&#39;/&#39;, function(req, res) {
    res.send(&#39;Hello World&#39;);
});</pre>

<p>如果你对匹配的path有特殊的限制，你可以使用正则表达式，例如，下面的可以匹配&quot;GET /commits/71dbb9c&quot;和&quot;GET /commits/71bb92..4c084f9&quot;。</p>

<pre>
router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res) {
    var from = req.params[0];
    var to = req.params[1];
    res.send(&#39;commit range &#39; + from + &#39;..&#39; + to);
});</pre>

<h4>router.param(name, callback)</h4>

<p>给路由参数添加回调触发器，这里的<strong>name</strong>是参数名，<strong>function</strong>是回调方法。回调方法的参数按序是请求对象，响应对象，下个中间件，参数值和参数名。虽然<strong>name</strong>在技术上是可选的，但是自Express V4.11.0之后版本不推荐使用(见下面)。</p>

<blockquote>
<p>不像<strong>app.param()</strong>，<strong>router.param()</strong>不接受一个数组作为路由参数。</p>
</blockquote>

<p>例如，当<strong>:user</strong>出现在路由路径中，你可以映射用户加载的逻辑处理来自动提供<strong>req.user</strong>给这个路由，或者对输入的参数进行验证。</p>

<pre>
router.param(&#39;user&#39;, function(req, res, next, id) {
    User.find(id, function(error, user) {
        if (err) {
            next(err);
        }
        else if (user){
            req.user = user;
        } else {
            next(new Error(&#39;failed to load user&#39;));
        }
    });
});</pre>

<p>对于<strong>Param</strong>的回调定义的路由来说，他们是局部的。它们不会被挂载的app或者路由继承。所以，定义在<strong>router</strong>上的<strong>param</strong>回调只有是在<strong>router</strong>上的路由具有这个路由参数时才起作用。</p>

<p>在定义<strong>param</strong>的路由上，<strong>param</strong>回调都是第一个被调用的，它们在一个请求-响应循环中都会被调用一次并且只有一次，即使多个路由都匹配，如下面的例子：</p>

<pre>
router.param(&#39;id&#39;, function(req, res, next, id) {
    console.log(&#39;CALLED ONLY ONCE&#39;);
    next();
});
router.get(&#39;/user/:id&#39;, function(req, res, next) {
    console.log(&#39;although this matches&#39;);
    next();
});
router.get(&#39;/user/:id&#39;, function(req, res) {
    console.log(&#39;and this mathces too&#39;);
    res.end();
});</pre>

<p>当GET /user/42，得到下面的结果:</p>

<pre>
CALLED ONLY ONCE
although this matches
and this matches too</pre>

<blockquote>
<p>下面章节描述的<strong>router.param(callback)</strong>在v4.11.0之后被弃用。</p>
</blockquote>

<p>通过只传递一个回调参数给<strong>router.param(name, callback)</strong>方法，<strong>router.param(naem, callback)</strong>方法的行为将被完全改变。这个回调参数是关于<strong>router.param(name, callback)</strong>该具有怎样的行为的一个自定义方法，这个方法必须接受两个参数并且返回一个中间件。</p>

<p>这个回调的第一个参数就是需要捕获的url的参数名，第二个参数可以是任一的JavaScript对象，其可能在实现返回一个中间件时被使用。 这个回调方法返回的中间件决定了当URL中包含这个参数时所采取的行为。</p>

<p>在下面的例子中，<strong>router.param(name, callback)</strong>参数签名被修改成了<strong>router.param(name, accessId)</strong>。替换接受一个参数名和回调，<strong>router.param()</strong>现在接受一个参数名和一个数字。</p>

<pre>
var express = require(&#39;express&#39;);
var app = express();
var router = express.Router();
router.param(function(param, option){
    return function(req, res, next, val) {
        if (val == option) {
            next();
        }
        else {
            res.sendStatus(403);
        }
    }
});
router.param(&#39;id&#39;, 1337);
router.get(&#39;/user/:id&#39;, function(req, res) {
    res.send(&#39;Ok&#39;);
});
app.use(router);
app.listen(3000, function() {
    console.log(&#39;Ready&#39;);
}); </pre>

<p>在这个例子中，router.param(name. callback)参数签名保持和原来一样，但是替换成了一个中间件，定义了一个自定义的数据类型检测方法来检测user id的类型正确性。</p>

<pre>
router.param(function(param, validator) {
    return function(req, res, next, val) {
        if (validator(val)) {
            next();
        }
        else {
            res.sendStatus(403);
        }
    }
});
router.param(&#39;id&#39;, function(candidate) {
    return !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);
});</pre>

<h4>router.route(path)</h4>

<p>返回一个单例模式的路由的实例，之后你可以在其上施加各种HTTP动作的中间件。使用<strong>router.route()</strong>来避免重复路由名字(例如错字错误)--说的意思应该是使用<strong>router.route()</strong>这个单例方法来避免同一个路径多个路由实例。</p>

<p>构建在上面的<strong>router.param()</strong>例子之上，下面的代码展示了怎么使用<strong>router.route()</strong>来指定各种HTTP方法的处理句柄。</p>

<pre>
var router = express.Router();
router.param(&#39;user_id&#39;, function(req, res, next, id) {
    // sample user, would actually fetch from DB, etc...
    req.user = {
        id:id,
        name:&quot;TJ&quot;
    };
    next();
});
router.route(&#39;/users/:user_id&#39;)
    .all(function(req, res, next) {
        // runs for all HTTP verbs first
        // think of it as route specific middleware!
        next();
    })
    .get(function(req, res, next) {
        res.json(req.user);
    })
    .put(function(req, res, next) {
        // just an example of maybe updating the user
        req.user.name = req.params.name;
        // save user ... etc
        res.json(req.user);
    })
    .post(function(req, res, next) {
        next(new Error(&#39;not implemented&#39;));
    })
    .delete(function(req, res, next) {
        next(new Error(&#39;not implemented&#39;));
    })</pre>

<p>这种方法重复使用单个/usrs/:userid路径来添加了各种的HTTP方法。</p>

<h4>router.use([path], [function, ...] function)</h4>

<p>给可选的<strong>path</strong>参数指定的路径挂载给定的中间件方法，未指定<strong>path</strong>参数，默认值为<strong>/</strong>。 这个方法类似于<strong>app.use()</strong>。一个简单的例子和用例在下面描述。查阅<a href="https://www.runoob.com/w3cnote/express-4-x-api.html#toc_25">app.use()</a>获得更多的信息。</p>

<p>中间件就像一个水暖管道，请求在你定义的第一个中间件处开始，顺着中间件堆栈一路往下，如果路径匹配则处理这个请求。</p>

<pre>
var express = require(&#39;express&#39;);
var app = express();
var router = express.Router();
// simple logger for this router`s requests
// all requests to this router will first hit this middleware
router.use(function(req, res, next) {
    console.log(&#39;%s %s %s&#39;, req.method, req.url, req.path);
    next();
})
// this will only be invoked if the path starts with /bar form the mount ponit
router.use(&#39;/bar&#39;, function(req, res, next) {
    // ... maybe some additional /bar logging ...
    next();
})
// always be invoked
router.use(function(req, res, next) {
    res.send(&#39;hello world&#39;)；
})
app.use(&#39;/foo&#39;, router);
app.listen(3000);</pre>

<p>对于中间件function，挂载的路径是被剥离的和不可见的。关于这个特性主要的影响是对于不同的路径，挂载相同的中间件可能对代码不做改动，尽管其前缀已经改变。</p>

<p>你使用router.use()定义中间件的顺序很重要。中间们是按序被调用的，所以顺序决定了中间件的优先级。例如，通常日志是你将使用的第一个中间件，以便每一个请求都被记录。</p>

<pre>
var logger = require(&#39;morgan&#39;);
router.use(logger());
router.use(express.static(__dirname + &#39;/public&#39;));
router.use(function(req, res) {
    res.send(&#39;Hello&#39;);
});</pre>

<p>现在为了支持你不希望记录静态文件请求，但为了继续记录那些定义在<strong>logger()</strong>之后的路由和中间件。你可以简单的将<strong>static()</strong>移动到前面来解决：</p>

<pre>
router.use(express.static(__dirname + &#39;/public&#39;));
router.use(logger());
router.use(function(req, res){
  res.send(&#39;Hello&#39;);
});</pre>

<p>另外一个确凿的例子是从不同的路径托管静态文件，你可以将<strong>./public</strong>放到前面来获得更高的优先级:</p>

<pre>
app.use(express.static(__dirname + &#39;/public&#39;));
app.use(express.static(__dirname + &#39;/files&#39;));
app.use(express.static(__dirname + &#39;/uploads&#39;));</pre>

<p><strong>router.use()</strong>方法也支持命名参数，以便你的挂载点对于其他的路由而言，可以使用命名参数来进行预加载，这样做是很有益的。</p>
