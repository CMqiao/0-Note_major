<h1><a href="http://www.cnblogs.com/lcngu/p/5470695.html" id="cb_post_title_url">Mybatis学习--Mapper.xml映射文件</a></h1>

<ul>
	<li><strong>简介</strong></li>
</ul>

<p><strong>　　</strong>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。</p>

<p>　　映射文件中有很多属性，常用的就是parameterType(输入类型)、resultType(输出类型)、resultMap（）、rparameterMap（）。</p>

<ul>
	<li><strong>parameterType(输入类型)</strong></li>
</ul>

<p><strong>　　</strong>1、#{}与${}</p>

<p>　　#{}实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#{}表示一个占位符即?。</p>

<p>&nbsp;</p>

<pre>
1     &lt;!-- 根据id查询用户信息 --&gt;
2     &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;
3         select * from user where id = #{id}
4     &lt;/select&gt;        </pre>

<p>&nbsp;</p>

<p>　　使用占位符#{}可以有效防止sql注入，在使用时不需要关心参数值的类型，mybatis会自动进行java类型和jdbc类型的转换。#{}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</p>

<p>　　${}和#{}不同，通过${}可以将parameterType&nbsp;传入的内容拼接在sql中且不进行jdbc类型转换，&nbsp;${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。使用${}不能防止sql注入，但是有时用${}会非常方便，如下的例子：</p>

<p>　　</p>

<pre>
1 　　&lt;!-- 根据名称模糊查询用户信息 --&gt;
2     &lt;select id=&quot;selectUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;user&quot;&gt;
3        select * from user where username like &#39;%${value}%&#39;
4     &lt;/select&gt;</pre>

<p>&nbsp;</p>

<p>　　如果本例子使用#{}则传入的字符串中必须有%号，而%是人为拼接在参数中，显然有点麻烦，如果采用${}在sql中拼接为%的方式则在调用mapper接口传递参数就方便很多。</p>

<p>　　//如果使用占位符号则必须人为在传参数中加%</p>

<p>&nbsp;</p>

<p>　　List&lt;User&gt;&nbsp;list&nbsp;=&nbsp;userMapper.selectUserByName(&quot;%张三%&quot;);</p>

<p>　　//如果使用${}原始符号则不用人为在参数中加%</p>

<p>&nbsp;</p>

<p>　　List&lt;User&gt;list&nbsp;=&nbsp;userMapper.selectUserByName(&quot;张三&quot;);</p>

<p>　　再比如order&nbsp;by排序，如果将列名通过参数传入sql，根据传的列名进行排序，应该写为：</p>

<p>　　ORDER&nbsp;BY&nbsp;${columnName}，如果使用#{}将无法实现此功能。</p>

<p>　　2、传递简单类型</p>

<p>　　传递简单类型只需要注意#{}与${}的使用就可以。</p>

<p>　　3、传递pojo对象</p>

<p>　　Mybatis使用ognl表达式解析对象字段的值，如下例子：</p>

<p>&nbsp;</p>

<pre>
1 　　&lt;!&mdash;传递pojo对象综合查询用户信息 --&gt;
2     &lt;select id=&quot;findUserByUser&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;
3        select * from user where id=#{id} and username like &#39;%${username}%&#39;
4     &lt;/select&gt;
</pre>

<p>　　测试代码：</p>

<pre>
 1 Public void testFindUserByUser()throws Exception{
 2         //获取session
 3         SqlSession session = sqlSessionFactory.openSession();
 4         //获限mapper接口实例
 5         UserMapper userMapper = session.getMapper(UserMapper.class);
 6         //构造查询条件user对象
 7         User user = new User();
 8         user.setId(1);
 9         user.setUsername(&quot;管理员&quot;);
10         //传递user对象查询用户列表
11         List&lt;User&gt;list = userMapper.findUserByUser(user);
12         //关闭session
13         session.close();
14 }
</pre>

<p>　　如果将username写错后，会报以下异常</p>

<pre>
1 org.apache.ibatis.exceptions.PersistenceException: 
2 ### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &#39;dusername&#39; in &#39;class com.luchao.mybatis.first.po.User&#39;
3 ### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &#39;dusername&#39; in &#39;class com.luchao.mybatis.first.po.User&#39;</pre>

<p>　　可以看出MyBatis是通过反射来讲java对象映射到查询参数中的。</p>

<p>　　4、传递pojo包装对象</p>

<p>　　开发中通过pojo传递查询条件&nbsp;，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。</p>

<p>　　（1）、定义包装对象</p>

<p>　　定义包装对象将查询条件(pojo)以类组合的方式包装起来。</p>

<pre>
 1 public class QueryVo {
 2     private User user;
 3     //自定义用户扩展类
 4     private UserCustom custom;
 5     public User getUser() {
 6         return user;
 7     }
 8     public void setUser(User user) {
 9         this.user = user;
10     }
11     public UserCustom getCustom() {
12         return custom;
13     }
14     public void setCustom(UserCustom custom) {
15         this.custom = custom;
16     }
17 }
</pre>

<p>&nbsp;</p>

<p>　　（2）、&nbsp;mapper.xml映射文件</p>

<p>&nbsp;</p>

<pre>
1 &lt;select id=&quot;findUser&quot; parameterType=&quot;com.luchao.mybatis.first.po.QueryVo&quot; resultType=&quot;com.luchao.mybatis.first.po.User&quot;&gt;
2         select * from user where username like &#39;%${user.username}%&#39; and sex = #{user.sex}
3 &lt;/select&gt;</pre>

<p>&nbsp;</p>

<p>　　说明：mybatis底层通过ognl从pojo中获取属性值：#{user.username}，user即是传入的包装对象的属性。</p>

<p>　　5、传递hashmap</p>

<p>　　Sql映射文件定义如下：</p>

<p>&nbsp;</p>

<pre>
1 &lt;select id=&quot;findUserByIdMap&quot; parameterType=&quot;hashmap&quot; resultType=&quot;com.luchao.mybatis.first.po.User&quot;&gt;
2         select * from user where id = #{id}
3 &lt;/select&gt;</pre>

<p>&nbsp;</p>

<p>　　测试代码：</p>

<pre>
 1 Public void testFindUserByHashmap()throws Exception{
 2         //获取session
 3         SqlSession session = sqlSessionFactory.openSession();
 4         //获限mapper接口实例
 5         UserMapper userMapper = session.getMapper(UserMapper.class);
 6         //构造查询条件Hashmap对象
 7         HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
 8         map.put(&quot;id&quot;, 1);        
 9         //传递Hashmap对象查询用户列表
10         List&lt;User&gt;list = userMapper.findUserByHashmap(map);
11         //关闭session
12         session.close();
13 }
</pre>

<p>　　传递的map中的key和sql中解析的key不一致。测试结果没有报错，只是通过key获取值为空。这种用法一般用在POJO与数据库字段不一致的时候。</p>

<ul>
	<li><strong><strong><strong>parameterMap和resultMap</strong></strong></strong></li>
</ul>

<p><strong><strong><strong>　　</strong></strong></strong>resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系&nbsp;，resultMap实质上还需要将查询结果映射到pojo对象中。resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。</p>

<p>&nbsp;</p>

<p><strong>　　</strong>下面是在数据库列于POJO不一致的时候，将输入参数映射到数据库列的一种方式<strong>　</strong></p>

<pre>
 1 &lt;resultMap type=&quot;Book.dao.Book&quot; id=&quot;BookResultMap&quot;&gt;
 2   &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
 3   &lt;result column=&quot;name&quot; property=&quot;bookName&quot;/&gt;
 4   &lt;result column=&quot;price&quot; property=&quot;bookPrice&quot;/&gt;
 5  &lt;/resultMap&gt;
 6  
 7  &lt;!-- resultMap：resultMap的id ，bookName：resultMap的property，即实体类中的属性 --&gt;
 8  &lt;parameterMap type=&quot;Book.dao.Book&quot; id=&quot;BookParameterMap&quot;&gt;
 9   &lt;parameter property=&quot;bookName&quot; resultMap=&quot;BookResultMap&quot; /&gt;  
10   &lt;parameter property=&quot;bookPrice&quot; resultMap=&quot;BookResultMap&quot; /&gt;  
11  &lt;/parameterMap&gt;
12 &lt;!-- 保存一个Book --&gt;
13  &lt;insert id=&quot;saveBook&quot; parameterMap=&quot;BookParameterMap&quot;&gt;
14   insert into BOOK_MANAGE
15    (ID,NAME,PRICE)
16     values
17    (Bookmanage_Seq.Nextval,#{bookName},#{bookPrice})
18  &lt;/insert&gt;
19  
20  &lt;!-- 根据ID修改Book --&gt;
21  &lt;update id=&quot;updatePersnById&quot; parameterMap=&quot;BookParameterMap&quot;&gt;
22   update BOOK_MANAGE 
23    set 
24     NAME=#{bookName},
25     PRICE=#{bookPrice}
26    WHERE id=#{id}
27  &lt;/update&gt;
</pre>

<p>&nbsp;</p>

<p>　　当查询的结果与POJO名字不一致的时候，用resultMap来实现映射。</p>

<pre>
1 &lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt;
2         &lt;id column=&quot;id_&quot; property=&quot;id&quot; /&gt;
3         &lt;result column=&quot;username_&quot; property=&quot;username&quot; /&gt;
4 &lt;/resultMap&gt;
5 &lt;select id=&quot;findUserMapById&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;userMap&quot; &gt;
6         select id id_,username username_ from user where id = #{id}
7 &lt;/select&gt;
</pre>

<p>　　&lt;id&nbsp;/&gt;：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个&lt;id&nbsp;/&gt;。</p>

<p>　　Property：表示person类的属性。</p>

<p>　　Column：表示sql查询出来的字段名。</p>

<p>　　Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。</p>

<p>&nbsp;　 &nbsp;&lt;result&nbsp;/&gt;：普通结果，即pojo的属性。</p>

<p>&nbsp;</p>

<p>　　使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。</p>

<ul>
	<li><strong>resultType(输出类型)</strong></li>
</ul>

<p><strong>　　</strong>1、输出简单类型</p>

<p>　　映射文件：</p>

<p>&nbsp;</p>

<pre>
1 &lt;select id=&quot;findUserCount&quot; parameterType=&quot;user&quot; resultType=&quot;int&quot;&gt;
2        select count(1) from user
3 &lt;/select&gt;</pre>

<p>&nbsp;</p>

<p>　　输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。使用session的selectOne可查询单条记录。</p>

<p>　　2、输出pojo对象</p>

<p>　　映射文件</p>

<p>&nbsp;</p>

<pre>
1         &lt;!-- 根据id查询用户信息 --&gt;
2     &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;
3         select * from user where id = #{id}
4     &lt;/select&gt;    </pre>

<p>&nbsp;</p>

<p>　　3、输出pojo列表</p>

<p>　　映射文件：</p>

<pre>
1 &lt;!-- 根据名称模糊查询用户信息 --&gt;
2     &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;string&quot; resultType=&quot;user&quot;&gt;
3        select * from user where username like &#39;%${value}%&#39;
4     &lt;/select&gt;</pre>

<p>&nbsp;</p>

<p>　　注意：MyBatis会根据Mapper接口方法的返回类型来选择调用selectOne还是selectList方法，如果是List这调用selectList方法，如果是POJO则调用selectOne方法。</p>

<p>　　4、输出hashmap</p>

<p>&nbsp;</p>

<p>　　输出pojo对象可以改用hashmap输出类型，将输出的字段名称作为map的key，value为字段值。</p>

<p>　　resultType总结：</p>

<p>&nbsp;</p>

<p>　　输出pojo对象和输出pojo列表在sql中定义的resultType是一样的。返回单个pojo对象要保证sql查询出来的结果集为单条，内部使用session.selectOne方法调用，mapper接口使用pojo对象作为方法返回值。返回pojo列表表示查询出来的结果集可能为多条，内部使用session.selectList方法，mapper接口使用List&lt;pojo&gt;对象作为方法返回值。</p>

<ul>
	<li><strong>动态SQl</strong></li>
</ul>

<p>&nbsp;</p>

<p>　　mybatis核心&nbsp;对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。对查询条件进行判断，如果输入参数不为空才进行查询条件拼接。</p>

<p>　　1、if</p>

<pre>
 1 &lt;!-- 传递pojo综合查询用户信息 --&gt;
 2     &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;
 3         select * from user 
 4         where 1=1 
 5         &lt;if test=&quot;id!=null and id!=&#39;&#39;&quot;&gt;
 6         and id=#{id}
 7         &lt;/if&gt;
 8         &lt;if test=&quot;username!=null and username!=&#39;&#39;&quot;&gt;
 9         and username like &#39;%${username}%&#39;
10         &lt;/if&gt;
11 &lt;/select&gt;
</pre>

<p>　　2、Where</p>

<p>　　上面的配置也可以按如下来写：</p>

<pre>
 1 &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;
 2         select * from user 
 3         &lt;where&gt;
 4         &lt;if test=&quot;id!=null and id!=&#39;&#39;&quot;&gt;
 5         and id=#{id}
 6         &lt;/if&gt;
 7         &lt;if test=&quot;username!=null and username!=&#39;&#39;&quot;&gt;
 8         and username like &#39;%${username}%&#39;
 9         &lt;/if&gt;
10         &lt;/where&gt;
11 &lt;/select&gt;
</pre>

<p>　　&lt;where&nbsp;/&gt;可以自动处理第一个and。</p>

<p>　　3、foreach</p>

<p>　　向sql传递数组或List，mybatis使用foreach解析，如下：</p>

<p>　　如果我们需要传入多个ID来查询多个用户的信息，这也就可以使用foreach。我们先考虑下如果只写sql语句是如下：</p>

<p>&nbsp;</p>

<pre>
1 SELECT * FROM USERS WHERE username LIKE &#39;%张%&#39; AND (id =10 OR id =89 OR id=16)
2 SELECT * FROM USERS WHERE username LIKE &#39;%张%&#39;  id IN (10,89,16)</pre>

<p>&nbsp;</p>

<p>　　index：为数组的下标。</p>

<p>　　item：为数组每个元素的名称，名称随意定义</p>

<p>　　open：循环开始</p>

<p>　　close：循环结束</p>

<p>　　separator：中间分隔输出</p>

<p>　　通过POJO传入List，映射文件如下：</p>

<pre>
1 &lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt;
2             &lt;foreach collection=&quot;ids&quot; open=&quot; and id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt;
3                 #{id}
4             &lt;/foreach&gt;
5 &lt;/if&gt;</pre>

<p>　　或者：</p>

<pre>
1 &lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt;
2             &lt;foreach collection=&quot;ids&quot; open=&quot; and (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt;
3                  id = #{id}
4             &lt;/foreach&gt;
5 &lt;/if&gt;</pre>

<p>&nbsp;　　传递单个List</p>

<p>　　传递List类型在编写mapper.xml没有区别，唯一不同的是只有一个List参数时它的参数名为list。</p>

<p>　　配置文件如下：</p>

<p>&nbsp;</p>

<pre>
&lt;select id=&quot;selectUserByList&quot; parameterType=&quot;java.util.List&quot; resultType=&quot;user&quot;&gt;
        select * from user 
        &lt;where&gt;
        &lt;!-- 传递List，List中是pojo --&gt;
        &lt;if test=&quot;list!=null&quot;&gt;
        &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; open=&quot;and id in(&quot;separator=&quot;,&quot;close=&quot;)&quot;&gt;
            #{item.id} 
        &lt;/foreach&gt;
        &lt;/if&gt;
        &lt;/where&gt;
&lt;/select&gt;
</pre>

<p>&nbsp;</p>

<p>　　传递单个数组（数组中是POJO）</p>

<pre>
&lt;!-- 传递数组综合查询用户信息 --&gt;
    &lt;select id=&quot;selectUserByArray&quot; parameterType=&quot;Object[]&quot; resultType=&quot;user&quot;&gt;
        select * from user 
        &lt;where&gt;
        &lt;!-- 传递数组 --&gt;
        &lt;if test=&quot;array!=null&quot;&gt;
        &lt;foreach collection=&quot;array&quot; index=&quot;index&quot; item=&quot;item&quot; open=&quot;and id in(&quot;separator=&quot;,&quot;close=&quot;)&quot;&gt;
            #{item.id} 
        &lt;/foreach&gt;
        &lt;/if&gt;
        &lt;/where&gt;
&lt;/select&gt;
</pre>

<p>　　sql只接收一个数组参数，这时sql解析参数的名称mybatis固定为array，如果数组是通过一个pojo传递到sql则参数的名称为pojo中的属性名。</p>

<p>　　传递单个数组（数组中是简单类型）</p>

<p>　　配置文件如下：</p>

<pre>
 1 &lt;!-- 传递数组综合查询用户信息 --&gt;
 2 &lt;select id=&quot;selectUserByArray&quot; parameterType=&quot;Object[]&quot; resultType=&quot;user&quot;&gt;
 3         select * from user 
 4         &lt;where&gt;
 5         &lt;!-- 传递数组 --&gt;
 6         &lt;if test=&quot;array!=null&quot;&gt;
 7         &lt;foreach collection=&quot;array&quot;index=&quot;index&quot;item=&quot;item&quot;open=&quot;and id in(&quot;separator=&quot;,&quot;close=&quot;)&quot;&gt;
 8             #{item} 
 9         &lt;/foreach&gt;
10         &lt;/if&gt;
11         &lt;/where&gt;
12 &lt;/select&gt;
</pre>

<p>　　如果数组中是简单类型则写为#{item}，不用再通过ognl获取对象属性值了。</p>

<p>&nbsp;</p>

<p>&nbsp; &nbsp;　Sql片段</p>

<p>　　Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下：</p>

<p>　　映射文件如下：</p>

<p>&nbsp;</p>

<pre>
 1 &lt;!-- 传递pojo综合查询用户信息 --&gt;
 2     &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;
 3         select * from user 
 4         &lt;where&gt;
 5         &lt;if test=&quot;id!=null and id!=&#39;&#39;&quot;&gt;
 6         and id=#{id}
 7         &lt;/if&gt;
 8         &lt;if test=&quot;username!=null and username!=&#39;&#39;&quot;&gt;
 9         and username like &#39;%${username}%&#39;
10         &lt;/if&gt;
11         &lt;/where&gt;
12     &lt;/select&gt;
</pre>

<p>&nbsp;</p>

<p>　　如果有多个statement都使用相同的查询条件，那么就可以把查询条件抽取出来作为单独的Sql片段。</p>

<p>　　Sql片段配置：</p>

<pre>
1 &lt;sql id=&quot;query_user_where&quot;&gt;
2     &lt;if test=&quot;id!=null and id!=&#39;&#39;&quot;&gt;
3         and id=#{id}
4     &lt;/if&gt;
5     &lt;if test=&quot;username!=null and username!=&#39;&#39;&quot;&gt;
6         and username like &#39;%${username}%&#39;
7     &lt;/if&gt;
8 &lt;/sql&gt;
</pre>

<p>　　使用include引用：</p>

<pre>
1 &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;
2         select * from user 
3         &lt;where&gt;
4         &lt;include refid=&quot;query_user_where&quot;/&gt;
5         &lt;/where&gt;
6 &lt;/select&gt;
</pre>

<p>　　注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：&lt;include&nbsp;refid=&quot;namespace.sql片段&rdquo;/&gt;</p>

<p>　　Mapper配置文件中常用的基本属性就是这些，如果还有其他的特殊需求可以根据需要来进行修改配置。另外，在我们的设计中，如果已经定义好了基本的POJO在引用的时候可以在定义一个视图查询层的POJO在其中封装基本的POJO和自定义的POJO(继承基本的POJO)，这样就可以较容易实现扩展。当数据库需求有变化的时候可以不修改基本POJO，而修改自定义的POJO，这样就可以实现较好的扩展，而不影响其他模块。如果前端需求有变动，可以通过修改前端的POJO来实现较小的改动。如下实现：</p>

<p>　　基本的POJO类型：</p>

<pre>
 1 public class User {
 2     private int id;
 3     private String username;// 用户姓名
 4     private String sex;// 性别
 5     private Date birthday;// 生日
 6     private String address;// 地址
 7     public int getId() {
 8         return id;
 9     }
10     public void setId(int id) {
11         this.id = id;
12     }
13     public String getUsername() {
14         return username;
15     }
16     public void setUsername(String username) {
17         this.username = username;
18     }
19     public String getSex() {
20         return sex;
21     }
22     public void setSex(String sex) {
23         this.sex = sex;
24     }
25     public Date getBirthday() {
26         return birthday;
27     }
28     public void setBirthday(Date birthday) {
29         this.birthday = birthday;
30     }
31     public String getAddress() {
32         return address;
33     }
34     public void setAddress(String address) {
35         this.address = address;
36     }
37     @Override
38     public String toString() {
39         // TODO Auto-generated method stub
40         return this.id+&quot;-&quot;+this.username+&quot;-&quot;+this.sex+&quot;-&quot;+this.address+&quot;-&quot;+this.birthday.toString();
41     }
42     
43 }
</pre>

<p>　　自定义的POJO继承基本的POJO:</p>

<pre>
1 public class UserCustom extends User{
2 
3 }</pre>

<p>　　如果我们的数据库有变动，我们可以在UserCustom添加属性，只满足当前修改。</p>

<p>　　前端POJO实现：</p>

<pre>
 1 public class QueryVo {
 2     private User user;
 3     //自定义用户扩展类
 4     private UserCustom custom;
 5     public User getUser() {
 6         return user;
 7     }
 8     public void setUser(User user) {
 9         this.user = user;
10     }
11     public UserCustom getCustom() {
12         return custom;
13     }
14     public void setCustom(UserCustom custom) {
15         this.custom = custom;
16     }
17 }</pre>

<p>&nbsp;</p>

<p>　　可以满足基本的需求，如果我们在查询中需要加入其他查询条件，如：商品、订单等，只需要修改QueryVo，这样就可以实现较好的可扩展性。&nbsp;</p>
