<h1>fluentd 学习笔记</h1>

<p>最近为了做一些数据分析，把我自己服务器上所有应用的日志都通过 fluentd 转存到 mongodb 了，第一次用 fluentd，记录一些笔记。</p>

<p>因为是初学，绝大部分内容来源于官方文档<a href="https://blog.laisky.com/p/fluentd/#fn-config" target="_blank">2</a>，等实际线上使用一段时间后再来更新一些心得。</p>

<hr />
<h2>一、Install</h2>

<p>fluent 比较烦的一点是，从 gem 安装和从 rpm、yum 安装的名字不一样，连配置文件的路径都不一样，需要记住的是：</p>

<ul>
	<li>从 gem 安装的，配置文件和执行程序都叫做 fluent；</li>
	<li>从 rpm 安装的，配置文件和执行程序都叫做 td-agent。</li>
</ul>

<h3>1、安装 fluentd</h3>

<p>详细可参见<a href="http://docs.fluentd.org/v0.12/categories/installation" target="_blank">官方文档</a>。</p>

<p>以 CentOS 为例：</p>

<pre>
<code># 安装
$ sudo curl -L https://toolbelt.treasuredata.com/sh/install-redhat-td-agent2.sh | sh

# 启动
$ sudo /etc/init.d/td-agent start
</code></pre>

<h3>2、安装插件</h3>

<pre>
<code># 从 rpm 安装的话，
# 比如要使用下例的 mongo，需要安装
# $ sudo td-agent-gem install fluent-plugin-mongo
$ sudo td-agent-gem &lt;PLUGIN_NAME&gt;

# 从 gem 安装的话
$ sudo gem install &lt;PLUGIN_NAME&gt;
</code></pre>

<hr />
<h2>二、简介</h2>

<p>fluentd 是一个日志收集系统，通过丰富的插件，可以收集来自于各种系统或应用的日志，然后根据用户定义将日志做分类处理。</p>

<p>通过 fluentd，你可以非常轻易的实现像追踪日志文件并将其过滤后转存到 MongoDB 这样的操作。fluentd 可以彻底的将你从繁琐的日志处理中解放出来。</p>

<p>用图来做说明的话，使用 fluentd 以前，你的系统是这样的：</p>

<p><img alt="null" src="https://s2.laisky.com/images/fluentd-before.png" /></p>

<p>使用了 fluentd 后，你的系统会成为这样：</p>

<p><img alt="null" src="https://s2.laisky.com/images/fluentd-after.png" /></p>

<p>（图片来源<a href="https://blog.laisky.com/p/fluentd/#fn-refer" target="_blank">3</a>）</p>

<hr />
<h2>三、配置文件</h2>

<h3>1、路径</h3>

<p>分为两种情况：</p>

<ul>
	<li>如果是通过 gem 安装的，那么可以通过下列命令生成和编辑配置文件</li>
</ul>

<pre>
<code>$ sudo fluentd --setup /etc/fluent
$ sudo vi /etc/fluent/fluent.conf
</code></pre>

<ul>
	<li>如果是通过 RPM, Deb 或 DMG 安装的，那么配置文件在：</li>
</ul>

<pre>
<code>$ sudo vi /etc/td-agent/td-agent.conf
</code></pre>

<h3>2、重用</h3>

<p>你可以在配置文件里使用&nbsp;<code>@include</code>&nbsp;来切分你的配置文件，include 支持多种写法：</p>

<pre>
<code># 绝对路径
include /path/to/config.conf
# 相对路径
@include conf.d/*.conf
# 甚至 URL
@include http://example.com/fluent.conf
</code></pre>

<h3>3、数据格式</h3>

<p>在配置文件里你需要为很多参数赋值，这些值必须使用 fluentd 支持的数据格式，有下列这些：</p>

<ul>
	<li><code>string</code>：字符串，最常见的格式，详细支持语法见文档<a href="https://blog.laisky.com/p/fluentd/#fn-literal" target="_blank">1</a>；</li>
	<li><code>integer</code>：整数</li>
	<li><code>float</code>：浮点数；</li>
	<li><code>size</code>&nbsp;大小，仅支持整数
	<ul>
		<li><code>&lt;INTEGER&gt;k</code>&nbsp;或&nbsp;<code>&lt;INTERGER&gt;K</code>；</li>
		<li><code>&lt;INTEGER&gt;m</code>&nbsp;或&nbsp;<code>&lt;INTERGER&gt;M</code>；</li>
		<li><code>&lt;INTEGER&gt;g</code>&nbsp;或&nbsp;<code>&lt;INTERGER&gt;G</code>；</li>
		<li><code>&lt;INTEGER&gt;t</code>&nbsp;或&nbsp;<code>&lt;INTERGER&gt;T</code>。</li>
	</ul>
	</li>
	<li><code>time</code>：时间，也只支持整数；
	<ul>
		<li><code>&lt;INTEGER&gt;s</code>&nbsp;或&nbsp;<code>&lt;INTERGER&gt;S</code>；</li>
		<li><code>&lt;INTEGER&gt;m</code>&nbsp;或&nbsp;<code>&lt;INTERGER&gt;M</code>；</li>
		<li><code>&lt;INTEGER&gt;h</code>&nbsp;或&nbsp;<code>&lt;INTERGER&gt;H</code>；</li>
		<li><code>&lt;INTEGER&gt;d</code>&nbsp;或&nbsp;<code>&lt;INTERGER&gt;D</code>。</li>
	</ul>
	</li>
	<li><code>array</code>：按照 JSON array 解析；</li>
	<li><code>hash</code>：按照 JSON object 解析。</li>
</ul>

<hr />
<h2>四、命令</h2>

<p>配置文件的核心是各种命令块(directives)，每一种命令都是为了完成某种处理，命令与命令之前还可以组成串联关系，以 pipline 的形式流式的处理和分发日志。</p>

<p>最常见的方式就是 source 收集日志，然后由串联的 filter 做流式的处理，最后交给 match 进行分发。</p>

<p>同时你还可以用 label 将任务分组，用 error 处理异常，用 system 修改运行参数。</p>

<p>下面是详细的说明。</p>

<h3>1、source</h3>

<p>source 是 fluentd 的一切数据的来源，每一个 source 内都包含一个输入模块，比如原生集成的包含&nbsp;<code>http</code>&nbsp;和&nbsp;<code>forward</code>&nbsp;两个模块，分别用来接收 HTTP 请求和 TCP 请求：</p>

<pre>
<code># Receive events from 24224/tcp
# This is used by log forwarding and the fluent-cat command
&lt;source&gt;
  @type forward
  port 24224
&lt;/source&gt;

# http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}
&lt;source&gt;
  @type http
  port 9880
&lt;/source&gt;
</code></pre>

<p>当然，除了这两个外，fluentd 还有大量的支持各种协议或方式的 source 插件，比如最常用的&nbsp;<code>tail</code>&nbsp;就可以帮你追踪文件。</p>

<p>每一个具体的插件都包含其特有的参数，比如上例中&nbsp;<code>port</code>&nbsp;就是一个参数，当你要使用一个 source 插件的时候，注意看看有哪些参数是需要配置的，然后将其写到 source directive 内。</p>

<p>source dirctive 在获取到输入后，会向 fluent 的路由抛出一个事件，这个事件包含三个要素：</p>

<ul>
	<li>tag</li>
	<li>time</li>
	<li>record</li>
</ul>

<p>那上例代码中的第二个 source 举例，当我们发起一个&nbsp;<code>http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}</code>&nbsp;的请求时，这个 source 会抛出：</p>

<pre>
<code># generated by http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}
tag: myapp.access
time: (current time)
record: {&quot;event&quot;:&quot;data&quot;}
</code></pre>

<p>关于如何编写一个输入插件，可以参考文档<a href="https://blog.laisky.com/p/fluentd/#fn-input-plugin" target="_blank">4</a>。</p>

<h3>2、match</h3>

<p>match 用来指定动作，通过 tag 匹配 source，然后执行指定的命令来分发日志，最常见的用法就是将 source 收集的日志转存到数据库。</p>

<pre>
<code># http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}
&lt;source&gt;
  @type http
  port 9880
&lt;/source&gt;

# 将标记为 myapp.access 的日志转存到文件
&lt;match myapp.access&gt;
  @type file
  path /var/log/fluent/access
&lt;/match&gt;
</code></pre>

<p>上例中的&nbsp;<code>myapp.access</code>&nbsp;就是 tag，tag 有好几种匹配模式：</p>

<ul>
	<li><code>*</code>：匹配任意一个 tag；</li>
	<li><code>**</code>：匹配任意数量个 tag；</li>
	<li><code>a b</code>：匹配 a 或 b；</li>
	<li><code>{X,Y,Z}</code>：匹配 X, Y, Z 中的一个。</li>
</ul>

<p>比如我可以写成这样：</p>

<pre>
<code>&lt;match a.*&gt;
&lt;match **&gt;
&lt;match a.{b,c}&gt;
&lt;match a.* b.*&gt;
</code></pre>

<p>fluentd 按照 match 出现的顺序依次匹配，一旦匹配成功就不会再往下匹配，所以如果你先写了一个&nbsp;<code>match **</code>，然后后面的所有的 match 都会被忽略。</p>

<p>然后我们使用了&nbsp;<code>@type file</code>&nbsp;插件来处理事件，这个插件有一个 path 属性，用来指定输出文件。</p>

<p>用法和 source 几乎一模一样，不过 source 是抛出事件，match 是接收并处理事件。你同样可以找到大量的各式各样的输出插件，也可以参考文档<a href="https://blog.laisky.com/p/fluentd/#fn-output-plugin" target="_blank">5</a>自己写一个。</p>

<h3>3、filter</h3>

<p>filter 和 match 的语法几乎完全一样，但是 filter 可以串联成 pipeline，对数据进行串行处理，最终再交给 match 输出。</p>

<pre>
<code># http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}
&lt;source&gt;
  @type http
  port 9880
&lt;/source&gt;

&lt;filter myapp.access&gt;
  @type record_transformer
  &lt;record&gt;
    host_param &quot;#{Socket.gethostname}&quot;
  &lt;/record&gt;
&lt;/filter&gt;

&lt;match myapp.access&gt;
  @type file
  path /var/log/fluent/access
&lt;/match&gt;
</code></pre>

<p>这个例子里，filter 获取数据后，调用原生的&nbsp;<code>@type record_transformer</code>&nbsp;插件，在事件的 record 里插入了新的字段&nbsp;<code>host_param</code>，然后再交给 match 输出。</p>

<p>你可以参考文档<a href="https://blog.laisky.com/p/fluentd/#fn-filter-plugin" target="_blank">6</a>来学习如何编写自定义的 filter。</p>

<p>虽然各个插件都有各自的参数，不过 fluentd 为所有的插件都设定了一组默认的参数： -&nbsp;<code>@type</code>：指定插件类型； -&nbsp;<code>@id</code>：给插件指定一个 id； -&nbsp;<code>@label</code>：指定 label； -&nbsp;<code>@log_level</code>：指定插件接收的日志级别。</p>

<p>你可以在任意插件内指定这些参数。</p>

<h3>4、system</h3>

<p>fluentd 的相关设置，可以在启动时设置，也可以在配置文件里设置，包含：</p>

<ul>
	<li><code>log_level</code></li>
	<li><code>suppress_repeated_stacktrace</code></li>
	<li><code>emit_error_log_interval</code></li>
	<li><code>suppress_config_dump</code></li>
	<li><code>without_source</code></li>
</ul>

<h3>5、label</h3>

<p>label 用于将任务进行分组，方便复杂任务的管理。</p>

<p>你可以在 source 里指定&nbsp;<code>@label @&lt;LABEL_NAME&gt;</code>，这个 source 所触发的事件就会被发送给指定的 label 所包含的任务，而不会被后续的其他任务获取到。</p>

<p>看个例子：</p>

<pre>
<code>&lt;source&gt;
  @type forward
&lt;/source&gt;

&lt;source&gt;
  # 这个任务指定了 label 为 @SYSTEM
  # 会被发送给 &lt;label @SYSTEM&gt;
  # 而不会被发送给下面紧跟的 filter 和 match
  @type tail
  @label @SYSTEM
&lt;/source&gt;

&lt;filter access.**&gt;
  @type record_transformer
  &lt;record&gt;
    # ...
  &lt;/record&gt;
&lt;/filter&gt;
&lt;match **&gt;
  @type elasticsearch
  # ...
&lt;/match&gt;

&lt;label @SYSTEM&gt;
  # 将会接收到上面 @type tail 的 source event
  &lt;filter var.log.middleware.**&gt;
    @type grep
    # ...
  &lt;/filter&gt;
  &lt;match **&gt;
    @type s3
    # ...
  &lt;/match&gt;
&lt;/label&gt;
</code></pre>

<h3>6、error</h3>

<p>用来接收插件通过调用&nbsp;<code>emit_error_event</code>&nbsp;API 抛出的异常，使用方法和 label 一样，通过设定&nbsp;<code>&lt;label @ERROR&gt;</code>&nbsp;就可以接收到相关的异常。</p>

<hr />
<h2>五、Demo</h2>

<h3>1、Config</h3>

<p>一个监听 Nginx 日志的例子：</p>

<pre>
<code>&lt;source&gt;
  @type tail
  @id nginx-access
  @label @nginx
  path /var/log/nginx/access.log
  pos_file /var/lib/fluentd/nginx-access.log.posg
  tag nginx.access
  format /^(?&lt;remote&gt;[^ ]*) (?&lt;host&gt;[^ ]*) \[(?&lt;time&gt;[^\]]*)\] (?&lt;code&gt;[^ ]*) &quot;(?&lt;method&gt;\S+)(?: +(?&lt;path&gt;[^\&quot;]*) +\S*)?&quot; (?&lt;size&gt;[^ ]*)(?: &quot;(?&lt;referer&gt;[^\&quot;]*)&quot; &quot;(?&lt;agent&gt;[^\&quot;]*)&quot;)?$/
  time_format %d/%b/%Y:%H:%M:%S %z
&lt;/source&gt;

&lt;source&gt;
  @type tail
  @id nginx-error
  @label @nginx
  path /var/log/nginx/error.log
  pos_file /var/lib/fluentd/nginx-error.log.posg
  tag nginx.error

  format /^(?&lt;time&gt;\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}) \[(?&lt;log_level&gt;\w+)\] (?&lt;pid&gt;\d+).(?&lt;tid&gt;\d+): (?&lt;message&gt;.*)$/
&lt;/source&gt;

&lt;label @nginx&gt;
  &lt;match nginx.access&gt;
    @type mongo
    database nginx
    collection access
    host 10.47.12.119
    port 27016

    time_key time
    flush_interval 10s
  &lt;/match&gt;
  &lt;match nginx.error&gt;
    @type mongo
    database nginx
    collection error
    host 10.47.12.119
    port 27016

    time_key time
    flush_interval 10s
  &lt;/match&gt;
&lt;/label&gt;
</code></pre>

<p>为了匹配，你也需要修改 Nginx 的&nbsp;<code>log_format</code>&nbsp;为：</p>

<pre>
<code>log_format main &#39;$remote_addr $host [$time_local] $status &quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot;&#39;;
</code></pre>

<h3>2、Docker</h3>

<p>&nbsp;</p>

<p>我自己在用的一个&nbsp;<a href="https://github.com/Laisky/fluentd-docker-image/blob/nginx-mongo/docker-compose.yml" target="_blank">docker 的镜像和 docker-compose.yml</a>。</p>

<hr />
<ol>
	<li>
	<p><a href="https://github.com/fluent/fluentd/blob/master/example/v1_literal_example.conf" target="_blank">fluentd: 字符串格式</a>&nbsp;<a href="https://blog.laisky.com/p/fluentd/#fnref-literal" target="_blank" title="Jump back to footnote 1 in the text.">↩</a></p>
	</li>
	<li>
	<p><a href="http://docs.fluentd.org/articles/config-file" target="_blank">fluentd: configure</a>&nbsp;<a href="https://blog.laisky.com/p/fluentd/#fnref-config" target="_blank" title="Jump back to footnote 2 in the text.">↩</a></p>
	</li>
	<li>
	<p><a href="http://mayiwei.com/2014/03/03/fluentd-setup/" target="_blank">fluentd安装配置简介</a>&nbsp;<a href="https://blog.laisky.com/p/fluentd/#fnref-refer" target="_blank" title="Jump back to footnote 3 in the text.">↩</a></p>
	</li>
	<li>
	<p><a href="http://docs.fluentd.org/articles/input-plugin-overview" target="_blank">fluentd: Input Plugin Overview</a>&nbsp;<a href="https://blog.laisky.com/p/fluentd/#fnref-input-plugin" target="_blank" title="Jump back to footnote 4 in the text.">↩</a></p>
	</li>
	<li>
	<p><a href="http://docs.fluentd.org/articles/output-plugin-overview" target="_blank">fluentd: Output Plugin Overview</a>&nbsp;<a href="https://blog.laisky.com/p/fluentd/#fnref-output-plugin" target="_blank" title="Jump back to footnote 5 in the text.">↩</a></p>
	</li>
	<li>
	<p><a href="http://docs.fluentd.org/articles/filter-plugin-overview" target="_blank">fluentd: Filter Plugin Overview</a>&nbsp;<a href="https://blog.laisky.com/p/fluentd/#fnref-filter-plugin" target="_blank" title="Jump back to footnote 6 in the text.">↩</a></p>
	</li>
</ol>

<p>java API</p>

<ol start="1">
	<li>//&nbsp;private&nbsp;static&nbsp;FluentLogger&nbsp;LOG&nbsp;=&nbsp;FluentLogger.getLogger(&quot;app&quot;);&nbsp;&nbsp;</li>
	<li>//&nbsp;for&nbsp;remote&nbsp;fluentd&nbsp;&nbsp;</li>
	<li>//&nbsp;port&nbsp;24225&nbsp;&nbsp;</li>
	<li>//&nbsp;bind&nbsp;172.16.5.20&nbsp;&nbsp;</li>
	<li>//&nbsp;The&nbsp;method&nbsp;should&nbsp;be&nbsp;called&nbsp;only&nbsp;once.&nbsp;&nbsp;</li>
	<li>private&nbsp;static&nbsp;FluentLogger&nbsp;LOG&nbsp;=&nbsp;FluentLogger.getLogger(&quot;docker&quot;,&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;172.16.5.20&quot;,&nbsp;24225);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;FluentLoggerTest&nbsp;fluentLoggerTest&nbsp;=&nbsp;new&nbsp;FluentLoggerTest();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;fluentLoggerTest.doApplicationLogic();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;=====end&nbsp;main&nbsp;======&quot;);&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>public&nbsp;void&nbsp;doApplicationLogic()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Then,&nbsp;please&nbsp;create&nbsp;the&nbsp;events&nbsp;like&nbsp;this.&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;will&nbsp;send&nbsp;the&nbsp;event&nbsp;to&nbsp;fluentd,&nbsp;with&nbsp;tag&nbsp;&#39;app.follow&#39;&nbsp;and&nbsp;the&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;attributes&nbsp;&#39;from&#39;&nbsp;and&nbsp;&#39;to&#39;.&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String,&nbsp;Object&gt;&nbsp;data&nbsp;=&nbsp;new&nbsp;HashMap&lt;String,&nbsp;Object&gt;();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;data.put(&quot;from&quot;,&nbsp;&quot;userA&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;data.put(&quot;to&quot;,&nbsp;&quot;userB&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;LOG.log(&quot;test&quot;,&nbsp;data);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Close&nbsp;method&nbsp;in&nbsp;FluentLogger&nbsp;class&nbsp;should&nbsp;be&nbsp;called&nbsp;explicitly&nbsp;when&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;application&nbsp;is&nbsp;finished.&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;method&nbsp;closes&nbsp;socket&nbsp;connection&nbsp;with&nbsp;the&nbsp;fluentd.&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;FluentLogger.close();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//FluentLogger.closeAll();&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>Maven pom</p>

<p>&lt;logger.version&gt;0.2.1&lt;/logger.version&gt;<br />
&lt;dependency&gt;<br />
&nbsp; &nbsp; &lt;groupId&gt;org.fluentd&lt;/groupId&gt;<br />
&nbsp; &nbsp; &lt;artifactId&gt;fluent-logger&lt;/artifactId&gt;<br />
&nbsp; &nbsp; &lt;version&gt;${logger.version}&lt;/version&gt;<br />
&nbsp; &lt;/dependency&gt;</p>
