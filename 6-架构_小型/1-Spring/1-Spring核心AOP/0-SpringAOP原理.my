<h1>AOP原理</h1>

<h2>一&nbsp; SpringAOP中常用的实现</h2>

<p>两种代理：这两种代理都是实现spring AOP 的基础。</p>

<ul>
	<li>JDK：基于接口
	<ul>
		<li>原理：动态代理 + 反射</li>
		<li>定义一个类XxHandler，实现InvocationHandler接口，里边包含真实对象的实例（实际上是一个Object，具体真实对象在运行期赋值给Object），并使用反射调用真实对象的指定方法</li>
		<li>使用Proxy.newProxyInstance(ClassLoader,&nbsp;interfaces, InvocationHandler)创建代理对象，之后调用相应的真实对象的方法即可。
		<ul>
			<li>由于该方法的第二个对象是interface，所以JDK<strong>只能基于接口实现动态代理</strong>。</li>
		</ul>
		</li>
	</ul>
	</li>
	<li>CGLib：基于类
	<ul>
		<li>原理：字节码增强，动态生成字节码技术，即为将要拦截的类动态生成子类，然后在子类中拦截所有父类的调用并顺势织入横切逻辑。</li>
		<li>由于是创建子类，所以不能代理目标类中的private和final方法。</li>
	</ul>
	</li>
</ul>

<p>比较：</p>

<ul>
	<li>CGLib创建代理对象花费的时间长于JDK，因为要动态生成子类</li>
	<li>CGLib创建好的代理对象的性能优于JDK</li>
</ul>

<p>&nbsp;</p>

<h2>二&nbsp; 总览AOP实现机制</h2>

<p>在Java平台上可以使用多种方式实现AOP。下面提到的儿种方式是最经常使用的，而且也通过了 相应AOP产品的验证，它们可都是帮助我们的AOP在Java平台走向现实的蓰石。</p>

<h3>1、动态代理</h3>

<p>JDKL3之后，引入了动态代理（DynamicProxy)机制，可以在运行期间，<strong>为相应的接口</strong>（Interface) 动态生成对应的代理对象。所以，我们可以将横切关注点逻辑封装到动态代理的InvocationHandler 中，然后在系统运行期间，根据横切关.注点需要织入的校块位S,将横切逻辑织入到相应的代理类中。 以动态代理类为载体的横切逻辑，现在当然就可以与系统其他实现模块一起工作了。<br />
&rsquo;这种方式实现的唯一缺点或者说优点就是，所有需要织入横切关注点逻辑的模块类都得实现相应 的接口，因为动态代理机制只针对接口有效。当然，之前也说了，毕竟动态代理是在运行期间使用反 射，相对于编泽后的静态类的执行，性能上可能稍逊一些。 ,<br />
SpringAOP默认情况下采用这种机制实现AOP机能。Namxing也是，只支持动态代理机制。</p>

<h3>2、动态字节码增强</h3>

<p>我们知道，Java虚拟机加载的class文件都是符合一定规范的，所以，只要交给Java虚拟机运行的 文件符合Java class规范，程序的运行就没有问题。通常的class文件都是从Java源代码文件使用Javac编 译器编译而成的，但只要符合Javaclass规范，我们也可以使用ASM或者CGL1B等Java工具庠，在程序 运行期间，动态构建字节码的class文件。<br />
在这样的前提下，我们可以为需要织入横切逻辑的模块类在运行期间，通过动态字节码增强技术, 为这些系统模块类<strong>生成相应的子类</strong>，而将横切逻辑加到这些子类中，让应用程序在执行期间使用的是这些动态生成的子类，从而达到将横切逻辑织入系统的目的。<br />
<strong>使用动态字节码增强技术，即使模块类没有实现相应的接口，我们依然可以对其进行扩展，而不 用像动态代理那样受限于接口。不过，这种实现机制依然存在不足，如果耑要扩展的类以及类中的实 例方法等声明为final的话，则无法对其进行子类化的扩展。</strong><br />
Spring AOP在无法采用动态代理机制进行AOP功能扩展的时候，会使用CGLIB库的动态字节码增 强支持来实现AOP的功能扩展。</p>

<h3>3、Java代码生成</h3>

<p>实际上，如果我们从早期的J2EE开发走过来的话，或者具体点儿，如果我们接触过早期的EJB开 发的话，就己经接触了这种类型的AOP实现。<br />
□是否记得现在依然让人念念不忘的容器内声明性事务支持？<br />
□是否还记得CMP类型的实体Bean只需要声明接口，而不用给出相应的接口实现类？<br />
□适否还记得大多数应用服务器提供商都会提供特定的EJB部署工其，以帮助我们进行EJB的部 署？<br />
艰务屈于跨越整个系统的一种横切关注点，所以，EJB容器提供的声明性琪务支持，屈于一种AOP 功能校块实现。但早期EJB容器在实现这一功能的时候，大多会采用Java代码生成技术，这就是我们 不需要提供CMP的接口实现类的原因，也足EJB容器提供商大多提供部署接口或者专有部署工具的原 因。<br />
EJB容器根据部署描述符文件提供的织入信息，会为相应的功能模块类根据描述符所提供的信息 生成对应的hva代码，然后通过部署工具或者部署接口编译Java代码生成相应的Java类。之后，部署到 EJB荞器的功能模块类就可以正常工作了。<br />
<strong>这种方式比较古老，也就早期的EJB容器使用最多，现在己经退休了。</strong></p>

<h3>4、自定义类加载器</h3>

<p>所有的Java程序的class都要通过相应的类加载器（Classloader)加载到Java虚拟机之后才可以运行。 默认的类加载器会读取class字节码文件，然后按照class字节码规范，解析并加载这些class文件到虚拟 机运行。如果我们能够在这个class文件加载到虚拟机运行期间，将横切逻辑织入到class文件的话，是 不是就完成了 AOP和OOP的融合呢？<br />
我们可以通过自定义类加载器的方式完成横切逻辑到系统的织入，自定义类加载器通过读取外部 文件规定的织入规则和必要信息，在加载class文件期间就可以将横切逻辑添加到系统模块类的现有逻 辑中，然后将改动后的class交给Java虚拟机运行。偷梁换柱得漂亮，不是吗？<br />
通过类加载器，我们基本可以对大部分类以及相应的实例进行织入，<strong>功能与之前的几种方式相比 当然强大很多。不过这种方式最大的问题就处类加载器本身的使用。某些应用服务器会控制整个的类 加载体系，所以，在这样的场景下使用可能会造成一定的问题。</strong><br />
JBoss AOP和己经并入AspectJ项目的AspectWericz框架都是采用自定义类加载器的方式实现。</p>

<h3>5、AOL 扩展</h3>

<p>AOL扩展是最强大、也最难掌握的一种方式，我们之前提到的Aspect!就属于这种方式。在这种方 式中，AOP的各种概念在AOL中大都有一一对应的实体&loz;我们可以使用扩展过的AOL,实现任何AOP 概念实体甚至OOP概念实体，比如Aspect以及Class。所苟的AOP概念在AOL中得到了圾完美的表达。<br />
采用扩展的AOL,在AOP概念的表述上颇具实力，使得AOP涉及的所有横切关注点逻辑在进行织 入之前，可以自由自在地存活在自己的&ldquo;国度&rdquo;中。而且，具有强类型检杏，基本可以对横切关注点 要切入的系统运行时点有更全面的控制。而像&ldquo;编译到静态类可以提升系统运行性能&rdquo;，&ldquo;Java虚拟 机可以像加载平常类那样，加载已经织入相应逻辑的A0组件所在的类文件并运行&rdquo;等特点，我们之 前已经提过了。<br />
不过，该方式强大的代价就是，你需要重新学习一门扩展了旧有的语言的AOL或者全新的AOL。 建议你在看完SpringAOP框架之后，再做出你的决定，因为我们的观点一贯是K.I.S.S. (KeepItSimple Stupid) 〇<br />
7.4 AOP国家的公</p>
