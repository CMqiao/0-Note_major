<h2>Java中BIO,NIO,AIO的理解</h2>

<p>在高性能的IO体系设计中，有几个名词概念常常会使我们感到迷惑不解。具体如下：&nbsp;</p>

<p>1 什么是同步？&nbsp;<br />
2 什么是异步？&nbsp;<br />
3 什么是阻塞？&nbsp;<br />
4 什么是非阻塞？&nbsp;<br />
5 什么是同步阻塞？&nbsp;<br />
6 什么是同步非阻塞？&nbsp;<br />
7 什么是异步阻塞？&nbsp;</p>

<p>8 什么是异步非阻塞？</p>

<p>&nbsp;</p>

<p><strong>先来举个实例生活中的例子：</strong></p>

<p>如果你想吃一份宫保鸡丁盖饭：</p>

<p>同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！</p>

<p>同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！</p>

<p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。</p>

<p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p>

<p>&nbsp;</p>

<p>在弄清楚上面的几个问题之前，我们首先得明白什么是同步，异步，阻塞，非阻塞，只有这几个单个概念理解清楚了，然后在组合理解起来，就相对比较容易了。&nbsp;<br />
<br />
1,同步和异步是针对应用程序和内核的交互而言的。&nbsp;<br />
<br />
2,阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。&nbsp;&nbsp;<br />
<br />
<strong>由上描述基本可以总结一句简短的话，同步和异步是目的，阻塞和非阻塞是实现方式。</strong>&nbsp;<br />
<br />
<strong>1.同步：</strong>指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。自己上街买衣服，自己亲自干这件事，别的事干不了。&nbsp;</p>

<p><br />
<strong>2.异步：</strong>异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知） 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS）&nbsp;</p>

<p><br />
<strong>3.阻塞：</strong>所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止 去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。）&nbsp;</p>

<p><br />
<strong>4.非阻塞：</strong>非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待， 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。</p>

<p>&nbsp;</p>

<p><strong>一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。</strong>&nbsp;</p>

<p>同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。&nbsp;</p>

<p><br />
阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。&nbsp;<br />
<br />
同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。</p>

<p>&nbsp;</p>

<p>而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。&nbsp;</p>

<p><br />
所以,IO操作可以分为3类：同步阻塞（即早期的BIO操作）、同步非阻塞（NIO）、异步非阻塞（AIO）。&nbsp;</p>

<p><br />
<strong>同步阻塞(BIO)：</strong>&nbsp;<br />
在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。&nbsp;<br />
<strong>同步非阻塞(NIO)：</strong><br />
在此种方式下，用户进程发起一个IO操作以后便可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。&nbsp;<br />
<strong>异步非阻塞(AIO)：</strong></p>

<p>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p>

<p>&nbsp;</p>

<p><strong>同步阻塞IO（JAVA BIO）：&nbsp;</strong><br />
同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。&nbsp;<br />
<br />
<strong>同步非阻塞IO(Java NIO)：</strong></p>

<p>同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。&nbsp;<br />
<br />
<strong>异步阻塞IO（Java NIO）：&nbsp;</strong>&nbsp;<br />
此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！&nbsp;&nbsp;<br />
<br />
<strong>（Java AIO(NIO.2)）异步非阻塞IO:&nbsp;&nbsp;</strong><br />
在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。&nbsp;&nbsp;</p>

<p>&nbsp;</p>

<p><strong>BIO、NIO、AIO适用场景分析:&nbsp;</strong><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。&nbsp;</p>
