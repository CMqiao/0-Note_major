<h1><a href="http://blog.csdn.net/zhangerqing/article/details/8193118">Java之美之HashMap、HashTable</a></h1>

<h2><strong>集合类之番外篇：深入解析HashMap、HashTable</strong></h2>

<p><a href="http://lib.csdn.net/base/javase" target="_blank" title="Java SE知识库">Java</a>集合类是个非常重要的知识点，HashMap、HashTable、ConcurrentHashMap等算是集合类中的重点，可谓&ldquo;重中之重&rdquo;，首先来看个问题，如面试官问你：HashMap和HashTable有什么区别，一个比较简单的回答是：</p>

<p>1、HashMap是非线程安全的，HashTable是线程安全的。</p>

<p>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</p>

<p>3、因为线程安全的问题，HashMap效率比HashTable的要高。</p>

<p>能答出上面的三点，简单的面试，算是过了，但是如果再问：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？能把第二个问题完整的答出来，说明你的基础算是不错的了。带着这个问题，本章开始系<strong>Java之美[从菜鸟到高手演变]系列</strong>之深入解析HashMap和HashTable类应用而生！总想在文章的开头说点儿什么，但又无从说起。从最近的一些面试说起吧，感受就是：知识是永无止境的，永远不要觉得自己已经掌握了某些东西。如果对哪一块知识感兴趣，那么，请多多的花时间，哪怕最基础的东西也要理解它的原理，尽量往深了研究，在学习的同时，记得多与大家交流沟通，因为也许某些东西，从你自己的角度，是很难发现的，因为你并没有那么多的实验环境去发现他们。只有交流的多了，才能及时找出自己的不足，才能认识到：&ldquo;哦，原来我还有这么多不知道的东西！&rdquo;。</p>

<h2><strong>一、HashMap的内部存储结构</strong></h2>

<p>Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表，数组的特点：连续空间，寻址迅速，但是在删除或者添加元素的时候需要有较大幅度的移动，所以查询速度快，增删较慢。而链表正好相反，由于空间不连续，寻址困难，增删元素只需修改指针，所以查询慢、增删快。有没有一种<a href="http://lib.csdn.net/base/datastructure" target="_blank" title="算法与数据结构知识库">数据结构</a>来综合一下数组和链表，以便发挥他们各自的优势？答案是肯定的！就是：哈希表。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用&ldquo;拉链法&rdquo;，我们可以理解为&ldquo;链表的数组&rdquo;，如下图：</p>

<p><img alt="" src="http://img.my.csdn.net/uploads/201211/17/1353118778_2052.png" /></p>

<p>从上图中，我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。它的内部其实是用一个Entity数组来实现的，属性有key、value、next。接下来我会从初始化阶段详细的讲解HashMap的内部结构。</p>

<h3><strong><em>1、初始化</em></strong></h3>

<p>首先来看三个常量：<br />
static final int DEFAULT_INITIAL_CAPACITY = 16; 初始容量：16<br />
static final int MAXIMUM_CAPACITY = 1&nbsp;<br />
&lt;&lt; 30; 最大容量：2的30次方：1073741824<br />
static final float DEFAULT_LOAD_FACTOR = 0.75f;&nbsp;<br />
装载因子，后面再说它的作用<br />
来看个无参构造方法，也是我们最常用的：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;HashMap()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadFactor&nbsp;=&nbsp;DEFAULT_LOAD_FACTOR;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold&nbsp;=&nbsp;(int)(DEFAULT_INITIAL_CAPACITY&nbsp;*&nbsp;DEFAULT_LOAD_FACTOR);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table&nbsp;=&nbsp;new&nbsp;Entry[DEFAULT_INITIAL_CAPACITY];&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p>loadFactor、threshold的值在此处没有起到作用，不过他们在后面的扩容方面会用到，此处只需理解table=new Entry[DEFAULT_INITIAL_CAPACITY].说明，默认就是开辟16个大小的空间。另外一个重要的构造方法：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;HashMap(int&nbsp;initialCapacity,&nbsp;float&nbsp;loadFactor)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(initialCapacity&nbsp;&lt;&nbsp;0)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(&quot;Illegal&nbsp;initial&nbsp;capacity:&nbsp;&quot;&nbsp;+&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialCapacity);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(initialCapacity&nbsp;&gt;&nbsp;MAXIMUM_CAPACITY)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialCapacity&nbsp;=&nbsp;MAXIMUM_CAPACITY;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(loadFactor&nbsp;&lt;=&nbsp;0&nbsp;||&nbsp;Float.isNaN(loadFactor))&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(&quot;Illegal&nbsp;load&nbsp;factor:&nbsp;&quot;&nbsp;+&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadFactor);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Find&nbsp;a&nbsp;power&nbsp;of&nbsp;2&nbsp;&gt;=&nbsp;initialCapacity&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;capacity&nbsp;=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(capacity&nbsp;&lt;&nbsp;initialCapacity)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;capacity&nbsp;&lt;&lt;=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadFactor&nbsp;=&nbsp;loadFactor;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold&nbsp;=&nbsp;(int)(capacity&nbsp;*&nbsp;loadFactor);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table&nbsp;=&nbsp;new&nbsp;Entry[capacity];&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
就是说传入参数的构造方法，我们把重点放在：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>while&nbsp;(capacity&nbsp;&lt;&nbsp;initialCapacity)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;capacity&nbsp;&lt;&lt;=&nbsp;1;&nbsp;&nbsp;</li>
</ol>

<p><br />
上面，该代码的意思是，实际的开辟的空间要大于传入的第一个参数的值。举个例子：<br />
new HashMap(7,0.8),loadFactor为0.8，capacity为7，通过上述代码后，capacity的值为：8.（1 &lt;&lt; 2的结果是4,2 &lt;&lt; 2的结果为8&lt;此处感谢网友wego1234的指正&gt;）。所以，最终capacity的值为8，最后通过new Entry[capacity]来创建大小为capacity的数组，所以，这种方法最红取决于capacity的大小。</p>

<h3><em><strong>2、put(Object key,Object value)操作</strong></em></h3>

<p>当调用put操作时，首先判断key是否为null，如下代码1处：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>&lt;p&gt;public&nbsp;V&nbsp;put(K&nbsp;key,&nbsp;V&nbsp;value)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(key&nbsp;==&nbsp;null)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;putForNullKey(value);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;hash&nbsp;=&nbsp;hash(key.hashCode());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;indexFor(hash,&nbsp;table.length);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Entry&lt;K,V&gt;&nbsp;e&nbsp;=&nbsp;table[i];&nbsp;e&nbsp;!=&nbsp;null;&nbsp;e&nbsp;=&nbsp;e.next)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;k;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(e.hash&nbsp;==&nbsp;hash&nbsp;&amp;&amp;&nbsp;((k&nbsp;=&nbsp;e.key)&nbsp;==&nbsp;key&nbsp;||&nbsp;key.equals(k)))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;oldValue&nbsp;=&nbsp;e.value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.value&nbsp;=&nbsp;value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.recordAccess(this);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;oldValue;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&lt;/p&gt;&lt;p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modCount++;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addEntry(hash,&nbsp;key,&nbsp;value,&nbsp;i);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&lt;/p&gt;&nbsp;&nbsp;</li>
</ol>

<p><br />
如果<strong>key是null</strong>，则调用如下代码：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>private&nbsp;V&nbsp;putForNullKey(V&nbsp;value)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Entry&lt;K,V&gt;&nbsp;e&nbsp;=&nbsp;table[0];&nbsp;e&nbsp;!=&nbsp;null;&nbsp;e&nbsp;=&nbsp;e.next)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(e.key&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;oldValue&nbsp;=&nbsp;e.value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.value&nbsp;=&nbsp;value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.recordAccess(this);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;oldValue;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modCount++;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addEntry(0,&nbsp;null,&nbsp;value,&nbsp;0);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
就是说，获取Entry的第一个元素table[0]，并基于第一个元素的next属性开始遍历，直到找到key为null的Entry，将其value设置为新的value值。<br />
如果没有找到key为null的元素，则调用如上述代码的addEntry(0, null, value, 0);增加一个新的entry，代码如下：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>void&nbsp;addEntry(int&nbsp;hash,&nbsp;K&nbsp;key,&nbsp;V&nbsp;value,&nbsp;int&nbsp;bucketIndex)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;Entry&lt;K,V&gt;&nbsp;e&nbsp;=&nbsp;table[bucketIndex];&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table[bucketIndex]&nbsp;=&nbsp;new&nbsp;Entry&lt;K,V&gt;(hash,&nbsp;key,&nbsp;value,&nbsp;e);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size++&nbsp;&gt;=&nbsp;threshold)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(2&nbsp;*&nbsp;table.length);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
先获取第一个元素table[bucketIndex],传给e对象，新建一个entry，key为null，value为传入的value值，next为获取的e对象。如果容量大于threshold，容量扩大2倍。<br />
如果<strong>key不为null</strong>，这也是大多数的情况，重新看一下源码：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;V&nbsp;put(K&nbsp;key,&nbsp;V&nbsp;value)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(key&nbsp;==&nbsp;null)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;putForNullKey(value);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;hash&nbsp;=&nbsp;hash(key.hashCode());//---------------2---------------&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;indexFor(hash,&nbsp;table.length);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Entry&lt;K,V&gt;&nbsp;e&nbsp;=&nbsp;table[i];&nbsp;e&nbsp;!=&nbsp;null;&nbsp;e&nbsp;=&nbsp;e.next)&nbsp;{//--------------3-----------&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;k;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(e.hash&nbsp;==&nbsp;hash&nbsp;&amp;&amp;&nbsp;((k&nbsp;=&nbsp;e.key)&nbsp;==&nbsp;key&nbsp;||&nbsp;key.equals(k)))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;oldValue&nbsp;=&nbsp;e.value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.value&nbsp;=&nbsp;value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.recordAccess(this);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;oldValue;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//-------------------4------------------&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modCount++;//----------------5----------&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addEntry(hash,&nbsp;key,&nbsp;value,&nbsp;i);-------------6-----------&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
看源码中2处，首先会进行key.hashCode()操作，获取key的哈希值，hashCode()是Object类的一个方法，为本地方法，内部实现比较复杂，我们<br />
会在后面作单独的关于Java中Native方法的分析中介绍。hash()的源码如下：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>static&nbsp;int&nbsp;hash(int&nbsp;h)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;function&nbsp;ensures&nbsp;that&nbsp;hashCodes&nbsp;that&nbsp;differ&nbsp;only&nbsp;by&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;constant&nbsp;multiples&nbsp;at&nbsp;each&nbsp;bit&nbsp;position&nbsp;have&nbsp;a&nbsp;bounded&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;number&nbsp;of&nbsp;collisions&nbsp;(approximately&nbsp;8&nbsp;at&nbsp;default&nbsp;load&nbsp;factor).&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;^=&nbsp;(h&nbsp;&gt;&gt;&gt;&nbsp;20)&nbsp;^&nbsp;(h&nbsp;&gt;&gt;&gt;&nbsp;12);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;h&nbsp;^&nbsp;(h&nbsp;&gt;&gt;&gt;&nbsp;7)&nbsp;^&nbsp;(h&nbsp;&gt;&gt;&gt;&nbsp;4);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p>int i = indexFor(hash, table.length);的意思，相当于int i = hash %&nbsp;Entry[].length;得到i后，就是在Entry数组中的位置，（<del>上述代码5和6处是如果Entry数组中不存在新要增加的元素，则执行5,6处的代码，如果存在，即Hash冲突，则执行</del><del>&nbsp;3-4处的代码，此处HashMap中采用链地址法解决Hash冲突</del>。此处经网友<strong>bbycszh</strong>指正，发现上述陈述有些问题）。重新解释：其实不管Entry数组中i位置有无元素，都会去执行5-6处的代码，如果没有，则直接新增，如果有，则将新元素设置为Entry[0]，其next指针指向原有对象，即原有对象为Entry[1]。具体方法可以解释为下面的这段文字：（<strong>3-4处的代码只是检查在索引为i的这条链上有没有key重复的，有则替换且返回原值，程序不再去执行5-6处的代码，无则无处理</strong>）</p>

<p>上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。如， 第一个键值对A进来，通过计算其key的hash得到的i=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其i也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,i也等于0,那么C.next = B,Entry[0] = C；这样我们发现i=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起,也就是说数组中存储的是最后插入的元素。</p>

<p>到这里为止，HashMap的大致实现，我们应该已经清楚了。当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个i的链就会很长，会不会影响性能？HashMap里面设置一个因素（也称为因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。</p>

<h3><strong><em>2、get(Object key)操作</em></strong></h3>

<p>get(Object key)操作时根据键来获取值，如果了解了put操作，get操作容易理解，先来看看源码的实现：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;V&nbsp;get(Object&nbsp;key)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(key&nbsp;==&nbsp;null)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;getForNullKey();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;hash&nbsp;=&nbsp;hash(key.hashCode());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Entry&lt;K,V&gt;&nbsp;e&nbsp;=&nbsp;table[indexFor(hash,&nbsp;table.length)];&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;!=&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;=&nbsp;e.next)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;k;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(e.hash&nbsp;==&nbsp;hash&nbsp;&amp;&amp;&nbsp;((k&nbsp;=&nbsp;e.key)&nbsp;==&nbsp;key&nbsp;||&nbsp;key.equals(k)))//-------------------1----------------&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;e.value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
意思就是：1、当key为null时，调用getForNullKey()，源码如下：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>private&nbsp;V&nbsp;getForNullKey()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Entry&lt;K,V&gt;&nbsp;e&nbsp;=&nbsp;table[0];&nbsp;e&nbsp;!=&nbsp;null;&nbsp;e&nbsp;=&nbsp;e.next)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(e.key&nbsp;==&nbsp;null)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;e.value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p>2、当key不为null时，先根据hash函数得到hash值，在更具indexFor()得到i的值，循环遍历链表，如果有：key值等于已存在的key值，则返回其value。如上述get()代码1处判断。</p>

<p>总结下HashMap新增put和获取get操作：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>//存储时:&nbsp;&nbsp;</li>
	<li>int&nbsp;hash&nbsp;=&nbsp;key.hashCode();&nbsp;&nbsp;</li>
	<li>int&nbsp;i&nbsp;=&nbsp;hash&nbsp;%&nbsp;Entry[].length;&nbsp;&nbsp;</li>
	<li>Entry[i]&nbsp;=&nbsp;value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>//取值时:&nbsp;&nbsp;</li>
	<li>int&nbsp;hash&nbsp;=&nbsp;key.hashCode();&nbsp;&nbsp;</li>
	<li>int&nbsp;i&nbsp;=&nbsp;hash&nbsp;%&nbsp;Entry[].length;&nbsp;&nbsp;</li>
	<li>return&nbsp;Entry[i];&nbsp;&nbsp;</li>
</ol>

<p>理解了就比较简单。</p>

<p>此处附一个简单的HashMap小<a href="http://lib.csdn.net/base/datastructure" target="_blank" title="算法与数据结构知识库">算法</a>应用：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>package&nbsp;com.xtfggef.hashmap;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>import&nbsp;java.util.HashMap;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.util.Map;&nbsp;&nbsp;</li>
	<li>import&nbsp;java.util.Set;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>/**&nbsp;</li>
	<li>&nbsp;*&nbsp;打印在数组中出现n/2以上的元素&nbsp;</li>
	<li>&nbsp;*&nbsp;利用一个HashMap来存放数组元素及出现的次数&nbsp;</li>
	<li>&nbsp;*&nbsp;@author&nbsp;erqing&nbsp;</li>
	<li>&nbsp;*&nbsp;</li>
	<li>&nbsp;*/&nbsp;&nbsp;</li>
	<li>public&nbsp;class&nbsp;HashMapTest&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;[]&nbsp;a&nbsp;=&nbsp;{2,3,2,2,1,4,2,2,2,7,9,6,2,2,3,1,0};&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;Integer,&nbsp;Integer&gt;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;Integer,Integer&gt;();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;&nbsp;i&lt;a.length;&nbsp;i++){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(map.containsKey(a[i])){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;tmp&nbsp;=&nbsp;map.get(a[i]);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp+=1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(a[i],&nbsp;tmp);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(a[i],&nbsp;1);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;Integer&gt;&nbsp;set&nbsp;=&nbsp;map.keySet();//------------1------------&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Integer&nbsp;s&nbsp;:&nbsp;set)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(map.get(s)&gt;=a.length/2){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//--------------2---------------&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>此处注意两个地方，map.containsKey()，还有就是上述1-2处的代码。</p>

<p>理解了HashMap的上面的操作，其它的大多数方法都很容易理解了。搞清楚它的内部存储机制，一切OK！</p>

<h2><strong>二、HashTable的内部存储结构</strong></h2>

<p>HashTable和HashMap采用相同的存储机制，二者的实现基本一致，不同的是：</p>

<p>1、HashMap是非线程安全的，HashTable是线程安全的，内部的方法基本都是synchronized。</p>

<p>2、HashTable不允许有null值的存在。</p>

<p>在HashTable中调用put方法时，如果key为null，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等，但基本思想和HashMap一样。</p>

<h2><strong>三、HashTable和</strong><strong>ConcurrentHashMap的比较</strong></h2>

<p>如我开篇所说一样，ConcurrentHashMap是线程安全的HashMap的实现。同样是线程安全的类，它与HashTable在同步方面有什么不同呢？</p>

<p>之前我们说，synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，<strong>锁住的都是对象整体</strong>，但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象。关于concurrentLevel稍后介绍。</p>

<h3><em><strong>1、构造方法</strong></em></h3>

<p>为了容易理解，我们先从构造函数说起。ConcurrentHashMap是基于一个叫Segment数组的，其实和Entry类似，如下：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;ConcurrentHashMap()&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;this(16,&nbsp;0.75F,&nbsp;16);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
默认传入值16，调用下面的方法：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;ConcurrentHashMap(int&nbsp;paramInt1,&nbsp;float&nbsp;paramFloat,&nbsp;int&nbsp;paramInt2)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((paramFloat&nbsp;&lt;=&nbsp;0F)&nbsp;||&nbsp;(paramInt1&nbsp;&lt;&nbsp;0)&nbsp;||&nbsp;(paramInt2&nbsp;&lt;=&nbsp;0))&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(paramInt2&nbsp;&gt;&nbsp;65536)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paramInt2&nbsp;=&nbsp;65536;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j&nbsp;=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&lt;&nbsp;paramInt2)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;&lt;=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;this.segmentShift&nbsp;=&nbsp;(32&nbsp;-&nbsp;i);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;this.segmentMask&nbsp;=&nbsp;(j&nbsp;-&nbsp;1);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;this.segments&nbsp;=&nbsp;Segment.newArray(j);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(paramInt1&nbsp;&gt;&nbsp;1073741824)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paramInt1&nbsp;=&nbsp;1073741824;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k&nbsp;=&nbsp;paramInt1&nbsp;/&nbsp;j;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(k&nbsp;*&nbsp;j&nbsp;&lt;&nbsp;paramInt1)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++k;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;l&nbsp;=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(l&nbsp;&lt;&nbsp;k)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;&lt;&lt;=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i1&nbsp;=&nbsp;0;&nbsp;i1&nbsp;&lt;&nbsp;this.segments.length;&nbsp;++i1)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.segments[i1]&nbsp;=&nbsp;new&nbsp;Segment(l,&nbsp;paramFloat);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
你会发现比HashMap的构造函数多一个参数，paramInt1就是我们之前谈过的initialCapacity，就是数组的初始化大小，paramfloat为loadFactor（装载因子），而paramInt2则是我们所要说的concurrentLevel，这三个值分别被初始化为16,0.75,16，经过：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>while&nbsp;(j&nbsp;&lt;&nbsp;paramInt2)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;&lt;=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
后，j就是我们最终要开辟的数组的size值，当paramInt1为16时，计算出来的size值就是16.通过：</p>

<p>this.segments = Segment.newArray(j)后，我们看出了，最终稿创建的Segment数组的大小为16.最终创建Segment对象时：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>this.segments[i1]&nbsp;=&nbsp;new&nbsp;Segment(cap,&nbsp;paramFloat);&nbsp;&nbsp;</li>
</ol>

<p>需要cap值，而cap值来源于：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>int&nbsp;k&nbsp;=&nbsp;paramInt1&nbsp;/&nbsp;j;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;if&nbsp;(k&nbsp;*&nbsp;j&nbsp;&lt;&nbsp;paramInt1)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;++k;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;int&nbsp;cap&nbsp;=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;while&nbsp;(cap&nbsp;&lt;&nbsp;k)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;cap&nbsp;&lt;&lt;=&nbsp;1;&nbsp;&nbsp;</li>
</ol>

<p>组后创建大小为cap的数组。最后根据数组的大小及paramFloat的值算出了threshold的值：</p>

<p>this.threshold = (int)(paramArrayOfHashEntry.length * this.loadFactor)。</p>

<h3><strong><em>2、put操作</em></strong></h3>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;V&nbsp;put(K&nbsp;paramK,&nbsp;V&nbsp;paramV)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(paramV&nbsp;==&nbsp;null)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NullPointerException();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;hash(paramK.hashCode());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;segmentFor(i).put(paramK,&nbsp;i,&nbsp;paramV,&nbsp;false);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
与HashMap不同的是，如果key为null，直接抛出NullPointer异常，之后，同样先计算hashCode的值，再计算hash值，不过此处hash函数和HashMap中的不一样：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>private&nbsp;static&nbsp;int&nbsp;hash(int&nbsp;paramInt)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;paramInt&nbsp;+=&nbsp;(paramInt&nbsp;&lt;&lt;&nbsp;15&nbsp;^&nbsp;0xFFFFCD7D);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;paramInt&nbsp;^=&nbsp;paramInt&nbsp;&gt;&gt;&gt;&nbsp;10;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;paramInt&nbsp;+=&nbsp;(paramInt&nbsp;&lt;&lt;&nbsp;3);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;paramInt&nbsp;^=&nbsp;paramInt&nbsp;&gt;&gt;&gt;&nbsp;6;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;paramInt&nbsp;+=&nbsp;(paramInt&nbsp;&lt;&lt;&nbsp;2)&nbsp;+&nbsp;(paramInt&nbsp;&lt;&lt;&nbsp;14);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(paramInt&nbsp;^&nbsp;paramInt&nbsp;&gt;&gt;&gt;&nbsp;16);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
&nbsp;</p>

<p>&nbsp;</p>

<ol start="1">
	<li>final&nbsp;Segment&lt;K,&nbsp;V&gt;&nbsp;segmentFor(int&nbsp;paramInt)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this.segments[(paramInt&nbsp;&gt;&gt;&gt;&nbsp;this.segmentShift&nbsp;&amp;&nbsp;this.segmentMask)];&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p><br />
根据上述代码找到Segment对象后，调用put来操作：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>V&nbsp;put(K&nbsp;paramK,&nbsp;int&nbsp;paramInt,&nbsp;V&nbsp;paramV,&nbsp;boolean&nbsp;paramBoolean)&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;lock();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;localObject1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;localObject2;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;this.count;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i++&nbsp;&gt;&nbsp;this.threshold)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rehash();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap.HashEntry[]&nbsp;arrayOfHashEntry&nbsp;=&nbsp;this.table;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j&nbsp;=&nbsp;paramInt&nbsp;&amp;&nbsp;arrayOfHashEntry.length&nbsp;-&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap.HashEntry&nbsp;localHashEntry1&nbsp;=&nbsp;arrayOfHashEntry[j];&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap.HashEntry&nbsp;localHashEntry2&nbsp;=&nbsp;localHashEntry1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((localHashEntry2&nbsp;!=&nbsp;null)&nbsp;&amp;&amp;&nbsp;(((localHashEntry2.hash&nbsp;!=&nbsp;paramInt)&nbsp;||&nbsp;(!(paramK.equals(localHashEntry2.key))))))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localHashEntry2&nbsp;=&nbsp;localHashEntry2.next;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(localHashEntry2&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localObject1&nbsp;=&nbsp;localHashEntry2.value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!(paramBoolean))&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localHashEntry2.value&nbsp;=&nbsp;paramV;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localObject1&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.modCount&nbsp;+=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayOfHashEntry[j]&nbsp;=&nbsp;new&nbsp;ConcurrentHashMap.HashEntry(paramK,&nbsp;paramInt,&nbsp;localHashEntry1,&nbsp;paramV);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.count&nbsp;=&nbsp;i;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;localObject1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;finally&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;unlock();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p><br />
先调用lock()，lock是ReentrantLock类的一个方法，用当前存储的个数+1来和threshold比较，如果大于threshold，则进行rehash，将当前的容量扩大2倍，重新进行hash。之后对hash的值和数组大小-1进行按位于操作后，得到当前的key需要放入的位置，从这儿开始，和HashMap一样。</p>

<p>从上述的分析看出，<strong><em>ConcurrentHashMap基于concurrentLevel划分出了多个Segment来对key-value进行存储，从而避免每次锁定整个数组，在默认的情况下，允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。</em></strong></p>

<p>在多线程的环境中，相对于HashTable，ConcurrentHashMap会带来很大的性能提升！</p>

<p><strong><u>欢迎读者批评指正，有任何建议请联系:</u></strong></p>

<p><strong><u>EGG：xtfggef@gmail.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http://weibo.com/xtfggef</u></strong></p>

<h2><strong>四、HashMap常见问题分析</strong></h2>

<h3><em><strong>1、</strong></em><a href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/"><strong>分析多线程并发写HashMap线程被hang住的原因</strong></a></h3>

<p><em><strong>此处我觉得</strong></em>网友<strong><a href="mailto:huxb23@126">huxb23@126</a></strong>的一篇文章说的很好，因为是优秀的资源，此处我整理下搬到这儿。</p>

<p>以下内容转自博文：<a href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/">http://blog.163.com/huxb23@126/blog/static/625898182011211318854/</a>&nbsp;</p>

<p>先看原问题代码：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>import&nbsp;java.util.HashMap;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>public&nbsp;class&nbsp;TestLock&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;HashMap&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;TestLock()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;t1&nbsp;=&nbsp;new&nbsp;Thread()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;50000;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(new&nbsp;Integer(i),&nbsp;i);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;t1&nbsp;over&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;t2&nbsp;=&nbsp;new&nbsp;Thread()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;50000;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(new&nbsp;Integer(i),&nbsp;i);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;t2&nbsp;over&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1.start();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2.start();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;TestLock();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p><br />
就是启了两个线程，不断的往一个非线程安全的HashMap中put内容，put的内容很简单，key和value都是从0自增的整数（这个put的内容做的并不好，以致于后来干扰了我分析问题的思路）。对HashMap做并发写操作，我原以为只不过会产生脏数据的情况，但反复运行这个程序，会出现线程t1、t2被hang住的情况，多数情况下是一个线程被hang住另一个成功结束，偶尔会两个线程都被hang住。说到这里，你如果觉得不好好学习ConcurrentHashMap而在这瞎折腾就手下留情跳过吧。<br />
好吧，分析下HashMap的put函数源码看看问题出在哪，这里就罗列出相关代码（jdk1.6）：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;V&nbsp;put(K&nbsp;paramK,&nbsp;V&nbsp;paramV)&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;if&nbsp;(paramK&nbsp;==&nbsp;null)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;putForNullKey(paramV);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;hash(paramK.hashCode());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;int&nbsp;j&nbsp;=&nbsp;indexFor(i,&nbsp;this.table.length);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;for&nbsp;(Entry&nbsp;localEntry&nbsp;=&nbsp;this.table[j];&nbsp;localEntry&nbsp;!=&nbsp;null;&nbsp;localEntry&nbsp;=&nbsp;localEntry.next)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(localEntry.hash&nbsp;==&nbsp;i)&nbsp;{&nbsp;java.lang.Object&nbsp;localObject1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(((localObject1&nbsp;=&nbsp;localEntry.key)&nbsp;==&nbsp;paramK)&nbsp;||&nbsp;(paramK.equals(localObject1)))&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.lang.Object&nbsp;localObject2&nbsp;=&nbsp;localEntry.value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localEntry.value&nbsp;=&nbsp;paramV;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localEntry.recordAccess(this);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;localObject2;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;this.modCount&nbsp;+=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;addEntry(i,&nbsp;paramK,&nbsp;paramV,&nbsp;j);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>private&nbsp;V&nbsp;putForNullKey(V&nbsp;paramV)&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;for&nbsp;(Entry&nbsp;localEntry&nbsp;=&nbsp;this.table[0];&nbsp;localEntry&nbsp;!=&nbsp;null;&nbsp;localEntry&nbsp;=&nbsp;localEntry.next)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(localEntry.key&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.lang.Object&nbsp;localObject&nbsp;=&nbsp;localEntry.value;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localEntry.value&nbsp;=&nbsp;paramV;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localEntry.recordAccess(this);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;localObject;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;this.modCount&nbsp;+=&nbsp;1;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;addEntry(0,&nbsp;null,&nbsp;paramV,&nbsp;0);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>&nbsp;</p>

<p>通过jconsole（或者thread dump），可以看到线程停在了transfer方法的while循环处。这个transfer方法的作用是，当Map中元素数超过阈值需要resize时，它负责把原Map中的元素映射到新Map中。我修改了HashMap，加上了@标记2和@标记3的代码片断，以打印出死循环时的状态，结果死循环线程总是出现类似这样的输出：&ldquo;Thread-1,e==next:false,e==next.next:true,e:108928=108928,next:108928=108928,eq:true&rdquo;。<br />
这个输出表明：<br />
1）这个Entry链中的两个Entry之间的关系是：e=e.next.next，造成死循环。<br />
2）e.equals(e.next)，但e!=e.next。因为<a href="http://lib.csdn.net/base/softwaretest" target="_blank" title="软件测试知识库">测试</a>例子中两个线程put的内容一样，并发时可能同一个key被保存了多个value，这种错误是在addEntry函数产生的，但这和线程死循环没有关系。</p>

<p>接下来就分析transfer中那个while循环了。先所说这个循环正常的功能：src[j]保存的是映射成同一个hash值的多个Entry的链表，这个src[j]可能为null，可能只有一个Entry，也可能由多个Entry链接起来。假设是多个Entry，原来的链是(src[j]=a)-&gt;b（也就是src[j]=a,a.next=b,b.next=null），经过while处理后得到了(newTable[i]=b)-&gt;a。也就是说，把链表的next关系反向了。</p>

<p>再看看这个while中可能在多线程情况下引起问题的语句。针对两个线程t1和t2,这里它们可能的产生问题的执行序列做些个人分析：</p>

<p>1）假设同一个Entry列表[e-&gt;f-&gt;...]，t1先到，t2后到并都走到while中。t1执行&ldquo;e.next = newTable[i];newTable[i] = e;&rdquo;这使得e.next=null（初始的newTable[i]为null），newTable[i]指向了e。这时t2执行了&ldquo;e.next = newTable[i];newTable[i] = e;&rdquo;，这使得e.next=e，e死循环了。因为循环开始处的&ldquo;final Entry next = e.next;&rdquo;，尽管e自己死循环了，在最后的&ldquo;e = next;&rdquo;后，两个线程都会跳过e继续执行下去。</p>

<p>2）在while中逐个遍历Entry链表中的Entry而把next关系反向时，newTable[i]成为了被交换的引用，可疑的语句在于&ldquo;e.next = newTable[i];&rdquo;。假设链表e-&gt;f-&gt;g被t1处理成e&lt;-f&lt;-g，newTable[i]指向了g，这时t2进来了，它一执行&ldquo;e.next = newTable[i];&rdquo;就使得e-&gt;g，造成了死循环。所以，理论上来说，死循环的Entry个数可能很多。尽管产生了死循环，但是t1执行到了死循环的右边，所以是会继续执行下去的，而t2如果执行&ldquo;final Entry next = e.next;&rdquo;的next为null，则也会继续执行下去，否则就进入了死循环。</p>

<p>3）似乎情况会更复杂，因为即便线程跳出了死循环，它下一次做resize进入transfer时，有可能因为之前的死循环Entry链表而被hang住（似乎是一定会被hang住）。也有可能，在put检查Entry链表时（@标记1），因为Entry链表的死循环而被hang住。也似乎有可能，活着的线程和死循环的线程同时执行在while里后，两个线程都能活着出去。所以，可能两个线程平安退出，可能一个线程hang在transfer中，可能两个线程都被hang住而又不一定在一个地方。</p>

<p>4）我反复的测试，出现一个线程被hang住的情况最多，都是e=e.next.next造成的，这主要就是例子put两份增量数据造成的。我如果去掉@标记3的输出，有时也能复现两个线程都被hang住的情况，但加上后就很难复现出来。我又把put的数据改了下，比如让两个线程put范围不同的数据，就能复现出e=e.next，两个线程都被hang住的情况。</p>

<p>上面罗哩罗嗦了很多，一开始我简单的分析后觉得似乎明白了怎么回事，可现在仔细琢磨后似乎又不明白了许多。有一个细节是，每次死循环的key的大小也是有据可循的，我就不打哈了。感觉，如果样本多些，可能出现问题的原因点会很多，也会更复杂，我姑且不再蛋疼下去。至于有人提到ConcurrentHashMap也有这个问题，我觉得不大可能，因为它的put操作是加锁的，如果有这个问题就不叫线程安全的Map了。</p>

<h3><strong><em>2、HashMap中Value可以相同，但是键不可以相同</em></strong></h3>

<p>当插入HashMap的key相同时，会覆盖原有的Value，且返回原Value值，看下面的程序：</p>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;class&nbsp;Test&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap&lt;String,Integer&gt;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;String,Integer&gt;();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//出入两个Value相同的值，没有问题&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(&quot;egg&quot;,&nbsp;1);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(&quot;niu&quot;,&nbsp;1);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//插入key相同的值，看返回结果&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;egg&nbsp;=&nbsp;(Integer)&nbsp;map.put(&quot;egg&quot;,&nbsp;3);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(egg);&nbsp;&nbsp;&nbsp;//输出1&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(map.get(&quot;egg&quot;));&nbsp;&nbsp;&nbsp;//输出3，将原值1覆盖&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(map.get(&quot;niu&quot;));&nbsp;&nbsp;&nbsp;//输出1&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>相同的键会被覆盖，且返回原值。</p>

<h3><strong><em>3、HashMap按值排序</em></strong></h3>

<p>给定一个数组，求出每个数据出现的次数并按照次数的由大到小排列出来。我们选用HashMap来做，key存储数组元素，值存储出现的次数，最后用Collections的sort方法对HashMap的值进行排序。代码如下：</p>

<p><strong>[java]</strong>&nbsp;<a href="http://blog.csdn.net/zhangerqing/article/details/8193118#" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;" title="view plain">view plain</a>&nbsp;<a href="http://blog.csdn.net/zhangerqing/article/details/8193118#" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;" title="copy">copy</a></p>

<ol start="1">
	<li>public&nbsp;class&nbsp;Test&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data[]&nbsp;=&nbsp;{&nbsp;2,&nbsp;5,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;2,&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7,&nbsp;8,&nbsp;8,&nbsp;7,&nbsp;8,&nbsp;7,&nbsp;9,&nbsp;0&nbsp;};&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;Integer,&nbsp;Integer&gt;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;Integer,&nbsp;Integer&gt;();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;:&nbsp;data)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(map.containsKey(i))&nbsp;{//判断HashMap里是否存在&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(i,&nbsp;map.get(i)&nbsp;+&nbsp;1);//已存在，值+1&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(i,&nbsp;1);//不存在，新增&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//map按值排序&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Map.Entry&lt;Integer,&nbsp;Integer&gt;&gt;&nbsp;list&nbsp;=&nbsp;new&nbsp;ArrayList&lt;Map.Entry&lt;Integer,&nbsp;Integer&gt;&gt;(&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.entrySet());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collections.sort(list,&nbsp;new&nbsp;Comparator&lt;Map.Entry&lt;Integer,&nbsp;Integer&gt;&gt;()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;compare(Map.Entry&lt;Integer,&nbsp;Integer&gt;&nbsp;o1,&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map.Entry&lt;Integer,&nbsp;Integer&gt;&nbsp;o2)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(o2.getValue()&nbsp;-&nbsp;o1.getValue());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Map.Entry&lt;Integer,&nbsp;Integer&gt;&nbsp;m&nbsp;:&nbsp;list)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(m.getKey()&nbsp;+&nbsp;&quot;-&quot;&nbsp;+&nbsp;m.getValue());&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>输出：</p>

<p>2-6<br />
5-5<br />
3-4<br />
8-3<br />
7-3<br />
9-1<br />
0-1</p>

<p><strong>持续更新中，欢迎大家提供更加值得分析的问题，我们共同努力，不断完善！</strong></p>

<p>本章，（完）</p>

<p>&nbsp;</p>

<h2><a href="http://alex09.iteye.com/blog/539549">java中HashSet详解</a></h2>

<h3>HashSet 的实现</h3>

<p>对于 HashSet 而言，它是基于 HashMap 实现的，HashSet 底层采用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，查看 HashSet 的源代码，可以看到如下代码：&nbsp;<br />
<br />
Java代码&nbsp;</p>

<ol start="1">
	<li>public&nbsp;class&nbsp;HashSet&lt;E&gt;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;extends&nbsp;AbstractSet&lt;E&gt;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;implements&nbsp;Set&lt;E&gt;,&nbsp;Cloneable,&nbsp;java.io.Serializable&nbsp;&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;使用&nbsp;HashMap&nbsp;的&nbsp;key&nbsp;保存&nbsp;HashSet&nbsp;中所有元素&nbsp;&nbsp;</li>
	<li>&nbsp;private&nbsp;transient&nbsp;HashMap&lt;E,Object&gt;&nbsp;map;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;定义一个虚拟的&nbsp;Object&nbsp;对象作为&nbsp;HashMap&nbsp;的&nbsp;value&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;private&nbsp;static&nbsp;final&nbsp;Object&nbsp;PRESENT&nbsp;=&nbsp;new&nbsp;Object();&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;...&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;初始化&nbsp;HashSet，底层会初始化一个&nbsp;HashMap&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;HashSet()&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;E,Object&gt;();&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;以指定的&nbsp;initialCapacity、loadFactor&nbsp;创建&nbsp;HashSet&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;其实就是以相应的参数创建&nbsp;HashMap&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;HashSet(int&nbsp;initialCapacity,&nbsp;float&nbsp;loadFactor)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;E,Object&gt;(initialCapacity,&nbsp;loadFactor);&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;HashSet(int&nbsp;initialCapacity)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;E,Object&gt;(initialCapacity);&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;HashSet(int&nbsp;initialCapacity,&nbsp;float&nbsp;loadFactor,&nbsp;boolean&nbsp;dummy)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;=&nbsp;new&nbsp;LinkedHashMap&lt;E,Object&gt;(initialCapacity&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;loadFactor);&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;调用&nbsp;map&nbsp;的&nbsp;keySet&nbsp;来返回所有的&nbsp;key&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;Iterator&lt;E&gt;&nbsp;iterator()&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map.keySet().iterator();&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;调用&nbsp;HashMap&nbsp;的&nbsp;size()&nbsp;方法返回&nbsp;Entry&nbsp;的数量，就得到该&nbsp;Set&nbsp;里元素的个数&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;int&nbsp;size()&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map.size();&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;调用&nbsp;HashMap&nbsp;的&nbsp;isEmpty()&nbsp;判断该&nbsp;HashSet&nbsp;是否为空，&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;当&nbsp;HashMap&nbsp;为空时，对应的&nbsp;HashSet&nbsp;也为空&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;boolean&nbsp;isEmpty()&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map.isEmpty();&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;调用&nbsp;HashMap&nbsp;的&nbsp;containsKey&nbsp;判断是否包含指定&nbsp;key&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//HashSet&nbsp;的所有元素就是通过&nbsp;HashMap&nbsp;的&nbsp;key&nbsp;来保存的&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;boolean&nbsp;contains(Object&nbsp;o)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map.containsKey(o);&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;将指定元素放入&nbsp;HashSet&nbsp;中，也就是将该元素作为&nbsp;key&nbsp;放入&nbsp;HashMap&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;boolean&nbsp;add(E&nbsp;e)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map.put(e,&nbsp;PRESENT)&nbsp;==&nbsp;null;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;调用&nbsp;HashMap&nbsp;的&nbsp;remove&nbsp;方法删除指定&nbsp;Entry，也就删除了&nbsp;HashSet&nbsp;中对应的元素&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;boolean&nbsp;remove(Object&nbsp;o)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map.remove(o)==PRESENT;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;//&nbsp;调用&nbsp;Map&nbsp;的&nbsp;clear&nbsp;方法清空所有&nbsp;Entry，也就清空了&nbsp;HashSet&nbsp;中所有元素&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;void&nbsp;clear()&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.clear();&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;...&nbsp;&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;&nbsp;</li>
</ol>

<p><br />
<br />
<br />
由上面源程序可以看出，HashSet 的实现其实非常简单，它只是封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。&nbsp;<br />
<br />
HashSet 的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。&nbsp;<br />
掌握上面理论知识之后，接下来看一个示例程序，测试一下自己是否真正掌握了 HashMap 和 HashSet 集合的功能。&nbsp;<br />
Java代码&nbsp;</p>

<ol start="1">
	<li>&nbsp;class&nbsp;Name&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;first;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;last;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Name(String&nbsp;first,&nbsp;String&nbsp;last)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.first&nbsp;=&nbsp;first;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.last&nbsp;=&nbsp;last;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;equals(Object&nbsp;o)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(this&nbsp;==&nbsp;o)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(o.getClass()&nbsp;==&nbsp;Name.class)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;n&nbsp;=&nbsp;(Name)o;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;n.first.equals(first)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;n.last.equals(last);&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>public&nbsp;class&nbsp;HashSetTest&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;Name&gt;&nbsp;s&nbsp;=&nbsp;new&nbsp;HashSet&lt;Name&gt;();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.add(new&nbsp;Name(&quot;abc&quot;,&nbsp;&quot;123&quot;));&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.contains(new&nbsp;Name(&quot;abc&quot;,&nbsp;&quot;123&quot;)));&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;&nbsp;</li>
</ol>

<p><br />
<br />
<br />
上面程序中向 HashSet 里添加了一个 new Name(&quot;abc&quot;, &quot;123&quot;) 对象之后，立即通过程序判断该 HashSet 是否包含一个 new Name(&quot;abc&quot;, &quot;123&quot;) 对象。粗看上去，很容易以为该程序会输出 true。&nbsp;<br />
<br />
实际运行上面程序将看到程序输出 false，这是因为 HashSet 判断两个对象相等的标准除了要求通过 equals() 方法比较返回 true 之外，还要求两个对象的 hashCode() 返回值相等。而上面程序没有重写 Name 类的 hashCode() 方法，两个 Name 对象的 hashCode() 返回值并不相同，因此 HashSet 会把它们当成 2 个对象处理，因此程序返回 false。&nbsp;<br />
<br />
由此可见，当我们试图把某个类的对象当成 HashMap 的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的 equals(Object obj) 方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。&nbsp;<br />
如下程序就正确重写了 Name 类的 hashCode() 和 equals() 方法，程序如下：&nbsp;<br />
Java代码&nbsp;</p>

<ol start="1">
	<li>class&nbsp;Name&nbsp;&nbsp;&nbsp;</li>
	<li>{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;first;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;last;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Name(String&nbsp;first,&nbsp;String&nbsp;last)&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.first&nbsp;=&nbsp;first;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.last&nbsp;=&nbsp;last;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;根据&nbsp;first&nbsp;判断两个&nbsp;Name&nbsp;是否相等&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;equals(Object&nbsp;o)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(this&nbsp;==&nbsp;o)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(o.getClass()&nbsp;==&nbsp;Name.class)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;n&nbsp;=&nbsp;(Name)o;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;n.first.equals(first);&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;根据&nbsp;first&nbsp;计算&nbsp;Name&nbsp;对象的&nbsp;hashCode()&nbsp;返回值&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;hashCode()&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;first.hashCode();&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString()&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;Name[first=&quot;&nbsp;+&nbsp;first&nbsp;+&nbsp;&quot;,&nbsp;last=&quot;&nbsp;+&nbsp;last&nbsp;+&nbsp;&quot;]&quot;;&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;public&nbsp;class&nbsp;HashSetTest2&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashSet&lt;Name&gt;&nbsp;set&nbsp;=&nbsp;new&nbsp;HashSet&lt;Name&gt;();&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set.add(new&nbsp;Name(&quot;abc&quot;&nbsp;,&nbsp;&quot;123&quot;));&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set.add(new&nbsp;Name(&quot;abc&quot;&nbsp;,&nbsp;&quot;456&quot;));&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(set);&nbsp;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p><br />
<br />
上面程序中提供了一个 Name 类，该 Name 类重写了 equals() 和 toString() 两个方法，这两个方法都是根据 Name 类的 first 实例变量来判断的，当两个 Name 对象的 first 实例变量相等时，这两个 Name 对象的 hashCode() 返回值也相同，通过 equals() 比较也会返回 true。&nbsp;<br />
<br />
程序主方法先将第一个 Name 对象添加到 HashSet 中，该 Name 对象的 first 实例变量值为&quot;abc&quot;，接着程序再次试图将一个 first 为&quot;abc&quot;的 Name 对象添加到 HashSet 中，很明显，此时没法将新的 Name 对象添加到该 HashSet 中，因为此处试图添加的 Name 对象的 first 也是&quot; abc&quot;，HashSet 会判断此处新增的 Name 对象与原有的 Name 对象相同，因此无法添加进入，程序在①号代码处输出 set 集合时将看到该集合里只包含一个 Name 对象，就是第一个、last 为&quot;123&quot;的 Name 对象。</p>
